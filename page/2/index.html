<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-五个角度分析android性能优化问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/五个角度分析android性能优化问题/" class="article-date">
  <time datetime="2016-04-17T16:35:03.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/五个角度分析android性能优化问题/">五个角度分析android性能优化问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="UI优化"><a href="#UI优化" class="headerlink" title="UI优化"></a>UI优化</h1><h2 id="一、丢帧和卡顿"><a href="#一、丢帧和卡顿" class="headerlink" title="一、丢帧和卡顿"></a>一、丢帧和卡顿</h2><h3 id="1-现象"><a href="#1-现象" class="headerlink" title="1.现象"></a>1.现象</h3><p>　　帧率fps：一秒钟内的帧数，即一秒钟GPU执行绘制的次数。 显示频率HZ：一秒钟更新显示的次数。<br>　　若60HZ（一般手机配置）搭配小于60fps的帧率，出现丢帧。<br>　　所以标准一次绘制的时间1000ms/60=16ms。时间长于16ms的绘制会出现丢帧，或者画面上下断裂等现象。</p>
<h3 id="1-原因及解决"><a href="#1-原因及解决" class="headerlink" title="1.原因及解决"></a>1.原因及解决</h3><p>　　1&gt;布局太深。采用布局扁平化设计，防止多层嵌套，可通过适当将LinearLayout改为RelativeLayout等方式降低布局的层数（其余情况线性布局由于其onDraw()方法调用次数相对少，因而比相对布局有更高的效率）。<br>　　2&gt;布局太多。<include> 标签来重用layout代码，以及<merge>删减多余或者额外的层级。<br>　　3&gt;UI绘制单元太多，CPU/GPU负载过重。减少不必要的绘制单元或控件。<br>　　4&gt;动画次数过多，16ms内无法完成。</merge></include></p>
<h3 id="2-工具"><a href="#2-工具" class="headerlink" title="2.工具"></a>2.工具</h3><p>　　开发者选项中的每帧占用时间，用条状显示在界面上。16ms为界限，蓝色表示measure和draw所用时间，红色表示渲染时间，黄色表示CPU等待GPU运行时间。（支付宝的”口碑外卖””蚂蚁聚宝””游戏中心”三个活动转场时有短暂的较长的紫色线条，知乎转场时黄红线条，两者Listview滑动时都表现出色小于16ms）</p>
<h2 id="二、OverDraw"><a href="#二、OverDraw" class="headerlink" title="二、OverDraw"></a>二、OverDraw</h2><h3 id="1-现象-1"><a href="#1-现象-1" class="headerlink" title="1.现象"></a>1.现象</h3><p>　　对不可见的UI进行了绘制或者更新，浪费资源，导致卡顿。<br>　　观测工具：开发者选项中的GPU过度渲染显示，控件重叠从低到高依次显示蓝，绿，粉，红色。</p>
<h3 id="2-解决（以background为例）"><a href="#2-解决（以background为例）" class="headerlink" title="2.解决（以background为例）"></a>2.解决（以background为例）</h3><p>　　1&gt;将Window的默认background移除。<br>　　2&gt;移除不必要的background。<br>　　3&gt;设置ImageView的transparent属性，使没有获取到图片时才调用background。</p>
<h2 id="三、自定义view的问题"><a href="#三、自定义view的问题" class="headerlink" title="三、自定义view的问题"></a>三、自定义view的问题</h2><p>　　自定义view的三大流程measure，draw和layout中measure和layout最耗时。<br>　　而且如果是自定义View碰到overDraw的情况，系统无法检测onDraw()中的操作而完成自动优化，canvas的clipRect()和quickReject()使创造一个只能在里面进行绘制的矩形区域，避免的过度渲染问题。</p>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><h2 id="一、频繁gc"><a href="#一、频繁gc" class="headerlink" title="一、频繁gc"></a>一、频繁gc</h2><h3 id="1现象。"><a href="#1现象。" class="headerlink" title="1现象。"></a>1现象。</h3><p>　　回收所有不可达对象的gc机制执行时，其他线程任务会暂时停滞。因此过长和过于频繁的gc降低效率会导致卡顿。</p>
<h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h3><p>　　1&gt;避免过于频繁的new对象和gc回收对象，比如避免for循环中出现创建对象语句。<br>　　2&gt;避免在onDraw()语句中创建对象。<br>　　3&gt;优化listview。构建adapter是使用contentView缓存，减少创建View对象次数。<br>　　4&gt;适用对象池模型。<br>　　5&gt;gc对数组、队列、数、图的回收效率低，尽早将不用的设为null。</p>
<h3 id="3-优化后的JVMgc机制。"><a href="#3-优化后的JVMgc机制。" class="headerlink" title="3.优化后的JVMgc机制。"></a>3.优化后的JVMgc机制。</h3><p>　　三级generation：young generation,old generation,permanent generation。不可达的对象依次进入每级内存区域，第一个区域进行快速创建和回收，同样对应最短的gc时间，后两个依次增加。</p>
<h2 id="二、leak"><a href="#二、leak" class="headerlink" title="二、leak"></a>二、leak</h2><h3 id="原因及解决"><a href="#原因及解决" class="headerlink" title="原因及解决"></a>原因及解决</h3><p>　　1.数据库的cursor没有及时关闭。及时调用close()对其关闭。<br>　　2.线程没有及时终止，会持续占据内存。及时调用remove()清除。<br>　　3.Bitmap对象不使用时采用recycle()释放内存。</p>
<h2 id="三、阻塞"><a href="#三、阻塞" class="headerlink" title="三、阻塞"></a>三、阻塞</h2><p>　　1.子线程。耗时任务如果在主线程执行，会导致UI线程阻塞，将耗时语句如下载文件、读写数据库等放到子线程执行。<br>　　2.线程池。线程不可能做到绝对的并行，只会通过时间片轮转的方式调度每个线程。因此需要一个线程池存放线程的缓存，否则大量线程的创建和销毁会消耗大量时间，入不敷出</p>
<h2 id="四、溢出"><a href="#四、溢出" class="headerlink" title="四、溢出"></a>四、溢出</h2><p>　　多数OOM都是因为Bitmap太大。<br>　　1.大图采用压缩图片。通过设置BitmapFactory.Options中inSampleSize的值对图片进行压缩。<br>　　2.多图采用缓存图片。使用LruCache（是一个LinkedHashMap ），从cache中去取出Bitmap显示，如果缓存中不存在就启动一个task去加载（from文件或网络）</p>
<h2 id="五、内存工具"><a href="#五、内存工具" class="headerlink" title="五、内存工具"></a>五、内存工具</h2><p>　　1.Heap Tool 进行内存快照，如需检测某个对象是否被回收，在System.gc()前后各拍一张内存快照进行对比。另外当heap size超过阈值时自动OOM。<br>　　2.Allocation Tracker 从开始到结束之间时间段监测内存调用情况，查出leak元凶。<br>　　3.Memory Monitor 查看APP整体消耗内存情况，以及发生GC的时刻。反映出当前操作带来的CPU和内存变化。<br>　　4.traceView。</p>
<h1 id="运算优化"><a href="#运算优化" class="headerlink" title="运算优化"></a>运算优化</h1><p>　　1.float比int计算慢几倍以上。<br>　　2.算法上进行优化。如使用排序中的快排归并堆排，查找使用二叉树和平衡树等。尽量不用O(n*n)时间复杂度以上的算法，必要时候可用空间换时间。<br>　　3.数据类型的选择。如hashmap,hashset的选择，StringBuilder代替String，ArrayList和LinkedList的选择<br>　　4.采用JNI，将耗时间的处理放到c/c++层来处理。<br>　　5.尽量采用文件操作，其速度比数据库的操作要快10倍左右。<br>　　6.如果方法用不到成员变量，可以把方法申明为static，性能会提高到15%到20%。static的变量如果不需要修改，应该使用static  final修饰符定义为常量。<br>　　7.使用单例模式。<br>　　8.提前或延迟操作，错开时间段提高TPS。Android中除了支持ScheduledExecutorService之外，还有一些delay操作，如handler.postDelayed，handler.postAtTime，handler.sendMessageDelayed，View.postDelayed，AlarmManager定时等。</p>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><p>　　1.对于现成的HTTP框架，有很多需要服务端配合的，比如：json数据格式代替xml或html，WebP代替jpg，支持断点续传，多个请求合并成一个，尽量不做重定向，服务器缓存以及负载均衡等。<br>　　2.对客户端本身，除了上述的实现，我们还需要合理的缓存，控制最大请求并发量，及时取消已失效的请求，过滤重复请求，timeout时间设置，请求优先级设置等。</p>
<h1 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h1><p>　　1.PowerManager.WakeLock可唤醒手机，调用完后记得恢复原始状态。<br>　　2.不同电量执行不同策略。获取手机充电状态信息，将耗电任务放到充电时进行等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/五个角度分析android性能优化问题/" data-id="cj2n6xntw000wvdpd1srtds27" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Broadcast-Receiver总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/Broadcast-Receiver总结/" class="article-date">
  <time datetime="2016-04-14T15:13:54.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/Broadcast-Receiver总结/">Broadcast_Receiver总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　广播的基础知识点不多，但最近都没怎么用到回头看看发现有些生疏，现总结一下方便以后快速回忆。</p>
<h2 id="一、发送广播："><a href="#一、发送广播：" class="headerlink" title="一、发送广播："></a>一、发送广播：</h2><h4 id="1-标准广播"><a href="#1-标准广播" class="headerlink" title="1. 标准广播"></a>1. 标准广播</h4><p>　　（Normal broadcasts）-异步执行：<br>　　Intent+sendBroadcast()。<br>　　Intent可以显式或隐式，显式即两个参数类和接收器，隐式一个参数为该广播的action。一般选择隐式发送。</p>
<h4 id="2-有序广播"><a href="#2-有序广播" class="headerlink" title="2. 有序广播"></a>2. 有序广播</h4><p>　　(Orderd broadcasts)-同步执行：<br>　　Intent+<strong>sendOrderedBroadcast()</strong>。<br>　　sendOrderedBroadcast()会有两个参数第二个为null。<br>　　接收器可以在<intent-filter>标签中添加priority优先级。（标准广播也可以设置优先级）<br>　　接收器可以在onReceive()方法中使用abortBroadcast()截断广播。</intent-filter></p>
<h2 id="二、接收广播："><a href="#二、接收广播：" class="headerlink" title="二、接收广播："></a>二、接收广播：</h2><p>　　注册广播+创建广播接收器子类</p>
<h4 id="1-注册广播：是”广播接收器”-主语-注册自己想要接收的”广播”-宾语-。"><a href="#1-注册广播：是”广播接收器”-主语-注册自己想要接收的”广播”-宾语-。" class="headerlink" title="1.注册广播：是”广播接收器”(主语)注册自己想要接收的”广播”(宾语)。"></a>1.注册广播：是”广播接收器”(主语)注册自己想要接收的”广播”(宾语)。</h4><p>　　1&gt; 动态注册（通过IntentFilter类）（必须程序启动后才能接受广播）</p>
<ul>
<li>1、先判断接收器为null即尚未创建对象，然后建广播接收器（系统的或自定义的）的子类的对象。</li>
<li>2、建<strong>IntentFilter</strong>对象，构造函数为目标广播action，或者对象调用addAction()来传入目标广播action。（通过action来选择监听什么广播）</li>
<li>3、调用<strong>registerReceiver()</strong>方法，参数一为接收器子类的对象，参数二为IntentFilter对象。（参数1为”主语”接收器，参数2为”宾语”广播）</li>
</ul>
<p>　　2&gt; 静态注册（通过intent-filter标签）</p>
<ul>
<li>1、manifest中建立<receiver>标签，name写BroadcastReceiver子类名。</receiver></li>
<li>2、其中再建立<intent-filter>标签，name可以写priority。</intent-filter></li>
<li>3、其中再建立<action>标签，name写目标广播action。</action></li>
<li>4、若是接受系统广播，可能还要在<uses-permission>中添加权限。</uses-permission></li>
</ul>
<h4 id="2-注销广播"><a href="#2-注销广播" class="headerlink" title="2.注销广播"></a>2.注销广播</h4><p>　　活动的onDestroy()方法中，先判断接收器不为Null，调用<strong>unregisterReceiver()</strong>，参数之一为receiver子类对象。接收器设为null。</p>
<h4 id="3-创建广播接收器子类。"><a href="#3-创建广播接收器子类。" class="headerlink" title="3.创建广播接收器子类。"></a>3.创建广播接收器子类。</h4><p>　　new—other—BroadcastReceiver。或者自建class继承BroadcastReceiver，并在manifest中声明<receiver>。</receiver></p>
<h2 id="三、回应广播"><a href="#三、回应广播" class="headerlink" title="三、回应广播"></a>三、回应广播</h2><p>　　重写BroadcastReceiver的子类中的onReceive()方法。</p>
<h2 id="四、本地广播"><a href="#四、本地广播" class="headerlink" title="四、本地广播"></a>四、本地广播</h2><p>比起全局广播仅有以下两个区别：<br>1、发送广播：sendBroadcast()方法要用<strong>LocalBroadcastManager</strong>类的对象来调用，其创建对象通过getInstance()方法。<br>2、注册广播：registerReceiver()方法和unregisterReceiver()方法也要用LocalBroadcastManager类的对象来调用。<br>3、本地广播不能用隐式注册，本地广播不怕机密数据泄漏、不怕恶意数据安全漏洞、更高效。</p>
<h2 id="五、intent的action。"><a href="#五、intent的action。" class="headerlink" title="五、intent的action。"></a>五、intent的action。</h2><p>　　1.自定义的action的命名一般是包名+.+大写。<br>　　2.系统的action举例。<br>　　　　1&gt;网络变化：<code>android.net.conn.CONNECTIVITY_CHANGE</code>。</p>
<ul>
<li>1.对应的类为<strong>ConnectivityManager</strong>，创建方式getSystemService(Context.CONNECTIVITY_SERVICE)</li>
<li>2.该类拥有的方法是<strong>getActiveNetworkInfo()</strong>，获取当前网络状况。</li>
<li>3.当前网络状况类<strong>NetworkInfo</strong>，拥有方法<strong>isAvailable()</strong>是否网络畅通，返回boolean值。</li>
<li>4.对应权限：<code>ACCESS_NETWORK_STATE</code><br>　　　　2&gt;开机：<code>android.intent.action.BOOT_COMPLETED</code>。对应权限：<code>RECEIVE_BOOT_COMPLETED</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/14/Broadcast-Receiver总结/" data-id="cj2n6xnt70006vdpdi2n38pfa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AIDL的简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/13/AIDL的简单使用/" class="article-date">
  <time datetime="2016-04-12T16:05:52.000Z" itemprop="datePublished">2016-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/13/AIDL的简单使用/">AIDL的简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="本文目标：进程间服务通信（多个进程共用一个服务）"><a href="#本文目标：进程间服务通信（多个进程共用一个服务）" class="headerlink" title="本文目标：进程间服务通信（多个进程共用一个服务）"></a>本文目标：进程间服务通信（多个进程共用一个服务）</h1><p>AIDL:<code>android interface definition language</code><br>android5.0后启动服务只能用显式intent不能用隐式。</p>
<h1 id="一、程序B启动程序A中的服务。"><a href="#一、程序B启动程序A中的服务。" class="headerlink" title="一、程序B启动程序A中的服务。"></a>一、程序B启动程序A中的服务。</h1><p>　　1.创立<strong>ComponentName</strong>对象，构造器参数一为包名，参数二为被启动的service包名+类名。<br>　　2.创立Intent对象，调用<strong>setComponent()</strong>，参数为ComponentName对象。<br>　　3.startService()。</p>
<p>　　注意：建立Service最好通过软件直接自动新建一个Service类。如果是手动建的类手动继承Service，需要在manifest下声明service并且加入以下权限：<br>    android:exported=”true”<br>    android:enabled=”true”<br>否则会报<code>java.lang.SecurityException: Not allowed to start service Intent { cmp=com.baidu.myapplication/.Myservice } without permission android.permission.BIND_REMOTEVIEWS</code>错误。</p>
<h1 id="二、程序B与程序A中的服务通信。"><a href="#二、程序B与程序A中的服务通信。" class="headerlink" title="二、程序B与程序A中的服务通信。"></a>二、程序B与程序A中的服务通信。</h1><p>　　1.A程序中Service同等级创建AIDI接口文件。然后Build—rebuild project或者make project。进入AIDI，建立抽象方法setAbc()（自定义）。<br>　　2.Service的onBinder()中返回一个”<strong>AIDL子类对象.Stub()</strong>“（这说明AIDL实际上是一个Binder类型），并重写接口原有方法basicTypes()和自建方法setAbc()。<br>　　3.在service中建立String全局变量abc，使setAbc()成为它的setter方法。（先有setter()后有变量）此时即可通过操作AIDL来向服务传递信息。<br>　　4.B程序中创建Folder–AIDLfolder，里面新建与A程序包名相同的包，A程序中的AIDL文件拷贝到B程序中这个包里。rebuild或make。<br>　　5.B程序中建立bindService()，将ServiceConnection接口的onServiceConnected()方法的第二个Binder类型的参数”service”，赋给一个自定义的AIDL类型变量b。这个赋值过程注意，不能直接将service强制类型转换成AIDL类型，因为这时转换成的是A包路径下的AIDL，必须用以下方式：<strong>b=AIDL接口名.Stub.asInterface(“参数service”)</strong>。<br>　　6.b调用setAbc()向服务传递信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/13/AIDL的简单使用/" data-id="cj2n6xnt60005vdpdxbq8o91s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-service的温故知新" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/service的温故知新/" class="article-date">
  <time datetime="2016-04-12T15:17:44.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/service的温故知新/">service的温故知新</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Service的基本创建步骤"><a href="#一、Service的基本创建步骤" class="headerlink" title="一、Service的基本创建步骤"></a>一、Service的基本创建步骤</h1><h2 id="活动中"><a href="#活动中" class="headerlink" title="活动中"></a>活动中</h2><p>　　1.启动服务，关闭服务，绑定服务，解绑服务：startservice(),stopservice(), bindservice(), unbindservice()。前两个参数参照startactivity()。都是由Activity调用的。<br>　　2.bindservice的参数(intent,<strong>ServiceConnection接口</strong>、（用来侦听服务的状态）的对象，Context.BIND_AUTO_CREATE),    unbindservice(ServiceConnection的对象)。<br>　　3.实现ServiceConnection接口的两个方法：onserviceconnected()服务绑定后执行 onservicedisconnected()服务被杀掉时执行。<br>　　4.bindservice()—-同时执行了oncreate()和onserviceconnected(),   unbindservice()—同时执行了onservicedisconnected()和ondestroy()。startservice()—-执行oncreate()和onStartCommand()    stopservice()—执行ondestroy()。</p>
<h2 id="服务中"><a href="#服务中" class="headerlink" title="服务中"></a>服务中</h2><p>　　1.继承Service后重写四个方法。onBind(), onCreate(), onDestroy(), onStartCommand()。<br>　　2.如需与活动建立连接，再自定义一个Callback接口和一个继承Binder的类。</p>
<h1 id="二、Service的生命周期："><a href="#二、Service的生命周期：" class="headerlink" title="二、Service的生命周期："></a>二、Service的生命周期：</h1><p>　　1.onCreate()和onDestroy()。<br>　　2.activity和service绑定时，退出活动服务也自动停止，没绑定则不停。<br>　　3.oncreate()和onstartcommand()的区别，每次startservice时就会onstartcommand（）一次，而oncreate()只在第一次startservice时执行，之后一直存在。<br>　　4.若startService()和bindService()都执行了，再想销毁服务，必须stopService()和unBindService()都执行。</p>
<h1 id="三、Activity与Service传递信息。"><a href="#三、Activity与Service传递信息。" class="headerlink" title="三、Activity与Service传递信息。"></a>三、Activity与Service传递信息。</h1><h2 id="1、活传服方法一利用onstartcommand-。"><a href="#1、活传服方法一利用onstartcommand-。" class="headerlink" title="1、活传服方法一利用onstartcommand()。"></a>1、活传服方法一利用onstartcommand()。</h2><p>　　activity要给service传递数据，Intent搞好后只需利用onstartcommand()参数中的intent接受即可</p>
<h2 id="2、活传服方法二利用onbind-。"><a href="#2、活传服方法二利用onbind-。" class="headerlink" title="2、活传服方法二利用onbind()。"></a>2、活传服方法二利用onbind()。</h2><p>　　（更方便更快，不需要Intent）（要传递的信息变量放在自定义类A中）（必须绑定后才能传递数据，方法一开始即可传递）<br>       核心思想：传递数据即想办法给对方的成员变量str赋值。  关键环节：onbind()方法的返回值会传递到活动中的onServiceConnected()的参数中。<br>　　1&gt; Myservice中建内部类A，继承<strong>Binder</strong>。<br>　　2&gt; A中str是服务要printf的数据，为其建立setter方法。（str并不是在A中定义的）<br>　　3&gt; 让onbind()的返回值为A的对象<br>　　4&gt;这个对象会被传递到Activity中的onserviceconnected()中的第二个参数”service”。（别问为什么）<br>　　5&gt;在活动中新建一个A类型（Myservice.A）的变量a，把service赋给a，a调用setStr()即可给Service服务类中的str赋值。</p>
<h2 id="3、侦听服务中数据（监听服务中的变化例如-）"><a href="#3、侦听服务中数据（监听服务中的变化例如-）" class="headerlink" title="3、侦听服务中数据（监听服务中的变化例如++）"></a>3、侦听服务中数据（监听服务中的变化例如++）</h2><p>　　–回调机制。将服务中的信息显示在活动UI中。<br>　　核心思想：上面是把str数据封装到set方法里，这里是把”接口的对象”封装到set方法里，而str数据藏在接口中的抽象方法里。<br>　　1&gt; 服务中新建一个接口Cb，定义一个抽象方法onchange(str)。通过这个方法传递服务到活动的数据。<br>　　2&gt; 建一个private类型的Cb成员变量cb，配上set和get方法来封装好(别人通过这俩方法调用它”NO!没人想调用cb”)。set方法是为了利用它的参数即接口的变量/对象cb。<br>　　3&gt; 在服务的oncreate()中（很可能是子线程中），将服务自己内部的可能是不停变换的那个数据，放入cb所调用的onchange(str)方法的参数里（自己当场建onchange()方法），传给了接口CB。【服务子线程onchange()传到了服务主线程onchange()】<br>　　4&gt; 内部类A中新建getsss()方法，返回MyServvv.this。(返回值是MyServvv)（因为A类的对象可以传递到活动中 见上回）<br>　　5&gt; 活动中，将onServiceConnected()的第二个IBinder类型参数赋给自己建的A类型的变量a（强制类型转换为MyServvv.A），a调用getservice()再调用set方法（而不是get方法），其参数就是接口的对象，用匿名类变成new Cb，重写方法onchange(str)，数据str传出。</p>
<h2 id="4、支线数据传到主线。"><a href="#4、支线数据传到主线。" class="headerlink" title="4、支线数据传到主线。"></a>4、支线数据传到主线。</h2><p>　　1&gt;匿名类方式创建一个<strong>Handle</strong>对象，重写Handle接口的方法handleMessage(Message msg)。<br>　　2&gt;支线中创建<strong>Message</strong>对象msg,调用setData，参数必须是<strong>Bundle</strong>过后的数据。<br>　　3&gt;handle对象调用setmessage（），参数是msg。就将数据传递到了匿名类的handlemessage中。<br>　　4&gt;匿名类中msg调用getdata()，再getstring()即可。</p>
<h1 id="四、一些细节："><a href="#四、一些细节：" class="headerlink" title="四、一些细节："></a>四、一些细节：</h1><p>　　1.<code>java.util.logging.Handler包的Handler</code>是错的。必须是<code>android.os.Handler</code>;。<br>　　2.message传递的是bundle包好的数据，handleMessage()中要对数据调用<strong>getData()+getString(key)</strong>两个方法才能提取出来。<br>　　3.如果不在onDestroy()设置结束服务，就会报<code>android.app.ServiceConnectionLeaked</code>错误。<br>　　4.如果服务子线程内部调用CallBack接口方法时没有if (callback != null) 条件句，会爆<code>java.lang.NullPointerException: Attempt to invoke interface method &#39;void com.baidu.myapplication.MySer$Callback.onChange(java.lang.String)on a null object reference</code>错误。因为此时callback变量还是null，我写的接口定义的语句还在下面没被执行到。<br>　　5.重要！Handler不能在子线程中创建对象，需在直接用外部UI线程创建好的Handler对象，否则报 <code>Can&#39;t create handler inside thread that has not called Looper.prepare()</code>错误。<br>　　6.开始、绑定、解绑、结束等方法里的intent对象必须共用，即提前初始化好Intent对象，才是指向同一个service的。<br>　　7.editText调用getText()同时必须toString()！<br>　　8.当通过onBinder()+Binder子类的方式，从活动传递信息给服务时，服务中接受并在子线程中展示的那个数据，必须在服务类下定义为全局变量，而Binder子类的作用仅仅是为该变量提供一个setter()方法供活动去修改。绝不可以把变量定义到Binder子类中作为局部变量再提供个getter()方法，而子线程中再new Binder子类，再通过getter()得到变量，这样接收到的数据是null，原因不明。</p>
<h1 id="五、那么Service和子线程该怎么选择呢"><a href="#五、那么Service和子线程该怎么选择呢" class="headerlink" title="五、那么Service和子线程该怎么选择呢"></a>五、那么Service和子线程该怎么选择呢</h1><p>　　1.程序的进程关了service还在运行，子线程不行。<br>　　2.长时间在后台运行，用service。<br>　　3.默认情况下，Service其实是运行在主线程中的，如果任务占用CPU时间多，资源大的情况下，要使用线程。<br>　　4.可以在任何有 Context 的地方调用Context.startService、 Context.stopService、 Context.bindService， Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。<br>　　5.Service的优先级高于后台挂起的Activity和Activity所创建的Thread，不易被杀。<br>　　6.其实应该考虑的问题是子线程应该在Activity开，还是Application中开，还是Service中开。前两者Thread的生命周期都不应该超出整个应用程序的生命周期，只有在Service里开线程可以在Activity结束后跟随service继续运行。
　　</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/12/service的温故知新/" data-id="cj2n6xnto000mvdpdhgpzdylh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-手机UI适配相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/10/手机UI适配相关/" class="article-date">
  <time datetime="2016-04-10T15:56:10.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/10/手机UI适配相关/">android手机UI适配相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="手机屏幕尺寸："><a href="#手机屏幕尺寸：" class="headerlink" title="手机屏幕尺寸："></a>手机屏幕尺寸：</h3><p>S5:5.1英寸</p>
<p>iPhone5s 4英寸；iPhone6 4.7英寸； iPhone6Plus 5.5英寸；mate7 6英寸</p>
<p>small——小于3英寸 ；</p>
<p>normal——小于4.5英寸；</p>
<p>large——小于7英寸；</p>
<p>extra large——小于10英寸  </p>
<h3 id="分辨率："><a href="#分辨率：" class="headerlink" title="分辨率："></a>分辨率：</h3><p>px*px(像素乘像素)  </p>
<p>WVGA:800*480(三星G9198) </p>
<p>DVGA:960*640(果4) </p>
<p>HD720：1280*720(红米，S3)（占有率第一）   </p>
<p>HD1080：1920*1080(MATE7，S5)（占有率第二）  </p>
<p>WQHD（2K屏）:2560*1440(find7,S6,S7) </p>
<p>　　逻辑分辨率：dp为单位。320dp和360dp两种（指逻辑宽度）。</p>
<h3 id="像素密度："><a href="#像素密度：" class="headerlink" title="像素密度："></a>像素密度：</h3><p>S5:432ppi  </p>
<p>120dpi(Ldpi)  </p>
<p>160dpi(Mdpi)  </p>
<p>240dpi(Hdpi)  </p>
<p>320dpi(XHdpi) （占有率第一）  </p>
<p>480dpi(XXHdpi)（占有率第二） </p>
<p>640dpi(XXXHdpi)(S7)。  </p>
<p>　　其中Mdpi的1px=1dp。XXHdpi的1dp=3px。XXXHdpi1dp=4px。  因为dp=(160/ppi)*px</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/10/手机UI适配相关/" data-id="cj2n6xnu10011vdpdtviwqpy7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-surfaceView入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/surfaceView入门/" class="article-date">
  <time datetime="2016-04-07T15:52:40.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/surfaceView入门/">surfaceView入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用过程：<br>　　1.主动更新时需要一个线程去操作，此时选择surfaceView而不选View。<br>　　2.新建类继承SurefaceView类，实现SurfaceHolder.CallBack接口。<br>　　3.实现一个构造器和三个方法：surfaceChanged() surfaceCreated() surfaceDestroyed()，参数都包含SurfaceHolder对象。<br>　　4.构造器中创建一个回调函数，getHolder().addCallBack(this)。初始化paint画笔。<br>　　5.自定义一个draw()方法，创建Canvas画布,并在开头和结尾添加锁定（getHolder().lockCanvas()）和解锁画布(getHolder().unlockCanvasAndPost(canvas))两条语句。中间用画布Canvas绘制之。<br>　　6.在surfaceCreated()（Or surfaceChanged()）中调用自定义方法draw()。</p>
<p>细节：<br>　　1.canvas的drawColor()改变的是画布背景，要放在绘制语句前面，否则背景会掩盖绘制的图像。paint的setColor()改变的是画笔的颜色。<br>　　2.canvas的save()和restore()方法成对出现，效果是让它俩之间的操作如rotate()（旋转画布）不影响restore()之后的操作。<br>　　3.SurfaceView有生命周期，若有线程要把关闭线程语句放在surfaceDestroy()里。</p>
<h2 id="利用容器绘制组合图形"><a href="#利用容器绘制组合图形" class="headerlink" title="利用容器绘制组合图形"></a>利用容器绘制组合图形</h2><p>　　思想：父容器类中有一个存放容器的集合，每个容器都是一个子view，并且都有一个继承了父容器类的类。所以每个子view也有自己的集合也可以添加其他子view（图形组合拼接）。</p>
<ul>
<li><p>1。新建一个容器类Container。<br>　　构造器中创建容器类泛型List集合，集合元素是容器（其实是子view）（每个子view是一个图形）。<br>　　新建两个方法。一个是draw()方法，另一个是childrenView()。在draw()中首先调用childrenView()(因为真正的绘制代码在这里)，然后foreach遍历集合中的子view（每个元素都是一个图形），再递归的调用自己即“container的draw()”。逻辑梳理：若集合中有了多个子view，那么子view肯定已经有了childrenView()这个绘制图形的能力，那就让这些子view依次调用childrenView()即可绘制。通过一个draw()的递归行为来实现这一目的。<br>　　新建两个向集合中添加和删除容器的方法。</p>
</li>
<li><p>2。新建一个代表具体图形的子view继承Container容器类。<br>　　构造器中初始化paint画笔。<br>　　重写父类的childrenView()，绘制图像（真正的图形的绘制代码在这里）。</p>
</li>
<li><p>3。新建一个类继承surfaceView实现Callback。<br>　　构造器中首先创建好Container和图形类的对象。别忘addCallBack()。<br>　　其次建立一个自定义方法drawuck()，内部先用锁画布+解锁画布包裹后再开始写代码。让多个图形拼接，即一个调用”添加集合方法”添加另一个，直到把母图形添加到container中。最后重写Container的draw()进行绘制。<br>　　绘制行为的调用关系：surfaceView调用Container的draw()，draw()递归的调用自己让集合每个元素调用childrenView()，子view类重写childrenView()添加真正的绘制行为。</p>
</li>
</ul>
<h2 id="利用容器使组合图形移动"><a href="#利用容器使组合图形移动" class="headerlink" title="利用容器使组合图形移动"></a>利用容器使组合图形移动</h2><ul>
<li>1.容器类<br>　　1&gt;容器类中建立坐标变量x,y，并为之添加get()set()方法。<br>　　2&gt;在容器类draw()方法中书写移动逻辑。调用canvas自带的瞬移方法translate()，两个参数为两个坐标的get()方法。将之用save()restore()包裹。</li>
<li>2.Rect类（用例类）<br>　　在Rect类中的childrenView()方法里，获取translate()的两个参数将其递增——get()作为set()的参数…</li>
<li>3.surfaceView子类<br>　　1&gt;surfaceView子类中建立两个方法——startTimer()，stopTimer()。<br>　　2&gt;在startTimer()中创建两个对象——Timer对象，TimerTask对象。<br>　　首先用schedule()方法启动Timer，参数为TimerTask对象和间隔时间。<br>　　然后在TimierTask接口匿名类中的run()里面写入drawuck()（surfaceView中自定义的绘制方法）。<br>　　3&gt;stopTimer()中确定timer不为空后cancel()，然后赋予null。<br>　　4&gt;分别将startTimer()和stopTimer()放入surfaceCreate()和surfaceDestroyed()。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/surfaceView入门/" data-id="cj2n6xntv000tvdpdv7t53x53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自己制作美美的View界面" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/自己制作美美的View界面/" class="article-date">
  <time datetime="2016-04-05T12:52:24.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/自己制作美美的View界面/">自己制作美美的View界面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　自定义view是android进阶之路上的必修课，能随心所欲做出自己设计的漂亮界面想想都小激动，终于等到发挥我设计天赋的时刻了，当然第一步还是得踏踏实实先把基本知识弄透彻。</p>
<h1 id="一、View的继承关系类"><a href="#一、View的继承关系类" class="headerlink" title="一、View的继承关系类"></a>一、View的继承关系类</h1><p>　　ViewRoot是连接WindowManager和DecorView的纽带。<br>　　Activity创建–DecorView添加到Window–创建ViewRootImpl对象–关联DecorView和ViewRootImpl。<br>　　DecorView是顶级View，默认内部包括一个竖直的LinearLayout，里面是Title和Content。</p>
<h1 id="二、三大流程之Measure流程"><a href="#二、三大流程之Measure流程" class="headerlink" title="二、三大流程之Measure流程"></a>二、三大流程之Measure流程</h1><h2 id="1-MeasureSpec相关"><a href="#1-MeasureSpec相关" class="headerlink" title="1.MeasureSpec相关"></a>1.MeasureSpec相关</h2><p>　　MeasureSpec（由父容器的MeasureSpec的mode和LayoutParams共同决定）决定了一个普通View的尺寸大小；MeasureSpec（由窗口大小和LayoutParams共同决定）也决定了一个DecorView的尺寸大小。<br>　　普通View的模式和尺寸大小的决定规律：<br><img src="http://7xs17a.com1.z0.glb.clouddn.com/20140603051415_0.gif.jpg" alt="1"></p>
<p>　　它是一个32位int值，前两位是SpecMode，后三十位是SpecSize。其中SpecMode分成三类：EXACTLY（具体数值、match_parent）,　AT_MOST（wrap_content）, UNSPECIFIED。</p>
<h2 id="2-View的Mesure流程"><a href="#2-View的Mesure流程" class="headerlink" title="2.View的Mesure流程"></a>2.View的Mesure流程</h2><p>（Measure方法测量自己即可）<br>　　用到的方法：measure(), onMeasure() ,setMeasuredDimension() ,wantWidth(), wantHeight()(这两个是自定义)  ，getSuggestedMinimumWidth() ,getSuggestedMinimumHeight(), getMode(), getSize()<br>　　1&gt;、View的measure()，是final所以不能改写，于是改写它所调用的onMeasure()方法。<br>　　2&gt;、setMeasuredDimention()方法是onMeasure()方法中的最主要方法，两个参数分别是宽和高，通过调用自定义的getWidth和getHeight来得到。<br>　　3&gt;、自定义的wantWidth()方法，有两个参数，第一个已经是size了，已经可以用来做返回值了（这样该方法就没意义了），是因为第二个参数是mesureSpec,用它来计算specSize，方法的目的正是考察specSize有没有必要代替掉size。考察依据：UNSPECIFIED模式则直接用size，EXACTLY模式和AT_MOST模式则用提取的specSize。<br>　　　　第一个参数size的来源：wantWidth()调用者调用了getSuggestedMinimumWidth()方法计算而出的。计算方法是直接返回android:minWidth这个属性值，若没有该属性值，就返回0（无背景）或是背景大小（有背景）。<br>　　　　第二个参数mesureSpec计算specSize的做法：通过MeasureSpec的getSize()方法，方法参数正是mesureSpec。同时通过MeasureSpec的getMode()方法得到specMode用来后面筛选。<br>　　4&gt;、如果通过继承View的方式自定义控件，wrap_content参数效果会和match_parent一样。所以必须重写onMeasure()。</p>
<h2 id="3-ViewGroup的Mesure流程"><a href="#3-ViewGroup的Mesure流程" class="headerlink" title="3.ViewGroup的Mesure流程"></a>3.ViewGroup的Mesure流程</h2><p>（Measure方法测量自己，和遍历的用Measure方法测量子元素）<br>　　测量子类时用的：measureChildren(),measureChild(),getLayoutParams(),getChildrenMeasuredSpec(),measure()<br>　　ViewGroup是抽象类，所以测量自己的任务交给子类LineaLayout等去实现：onMeasure()<br>　　1&gt;、在measureChildren()中遍历对子view执行measureChild()方法。<br>　　2&gt;、在measureChild()方法中，先提取child的LayoutParams参数getLayoutParams()，然后将params作为三个参数之一传给getChildMeasureSpec()方法得到measureSpec，最后调用measure()方法传入两个measureSpec作为参数进行测量。</p>
<h2 id="4-监听view的改变，调用view的尺寸信息。"><a href="#4-监听view的改变，调用view的尺寸信息。" class="headerlink" title="4.监听view的改变，调用view的尺寸信息。"></a>4.监听view的改变，调用view的尺寸信息。</h2><p>　　1&gt;、onWindowFocusChange()方法，参数为boolean类型的hasFocus。内部判断hanFocus为真即可getMeasuredWidth()和getMeasuredHeight()。<br>　　2&gt;、view.post()方法。用它建立的线程中可直接getMeasuredWidth()和getMeasuredHeight()。<br>　　3&gt;、addOnGlobalLayoutListener()监听器方法。用法同事件监听器。调用者为view树ViewTreeObserver的对象，创建对象方法为getViewTreeObserver()。<br>　　4&gt;、view.measure()方法。</p>
<h1 id="三、三大流程之Layout流程"><a href="#三、三大流程之Layout流程" class="headerlink" title="三、三大流程之Layout流程"></a>三、三大流程之Layout流程</h1><h2 id="1、相关过程"><a href="#1、相关过程" class="headerlink" title="1、相关过程"></a>1、相关过程</h2><p>　　layout作用是ViewGroup用来确定子元素的位置<br>　　layout()确定view本身的位置，onLayout()确定所有子元素的位置。<br>　　确定全部元素位置的层层递进过程：layout()（父元素自己定位）——onLayout()——setChildFrame()——layout()（子元素定位）——继续传递完成整个View树。</p>
<h2 id="2、获取尺寸的位置"><a href="#2、获取尺寸的位置" class="headerlink" title="2、获取尺寸的位置"></a>2、获取尺寸的位置</h2><p>　　应该在layout中get尺寸，因为onMeasure()中得到的是“测量宽/高”，layout过程中得到的是“最终宽/高”。下面两种情况会导致不同：<br>　　1&gt;、重写layout()，将其四个参数（四个顶点坐标）改动<br>　　2&gt;、View需要多次measure才能确定“测量宽/高”，前几次测量会有出入。</p>
<h1 id="四、三大流程之Draw流程"><a href="#四、三大流程之Draw流程" class="headerlink" title="四、三大流程之Draw流程"></a>四、三大流程之Draw流程</h1><h2 id="1、View的绘制过程"><a href="#1、View的绘制过程" class="headerlink" title="1、View的绘制过程"></a>1、View的绘制过程</h2><p>　　1&gt;、绘制背景：  drawBackground(canvas)<br>　　2&gt;、绘制自己：  onDraw(canvas)<br>　　3&gt;、绘制children：  dispatchDraw(canvas)<br>　　4&gt;、绘制装饰：  onDrawScrollBar(canvas)</p>
<h1 id="五、自定义View"><a href="#五、自定义View" class="headerlink" title="五、自定义View"></a>五、自定义View</h1><h2 id="1、继承View。"><a href="#1、继承View。" class="headerlink" title="1、继承View。"></a>1、继承View。</h2><p>　　1&gt;、新建类继承View，实现两个构造方法，两个参数的构造方法给布局用，一个参数的给活动用。<br>　　2&gt;、重写onDraw()，用它的参数canvas进行drawXXXX()绘制各种图形，新建Paint对象调用setColor(),setTextSize(),setARGB(),measureText()等方法进行修改。<br>　　3&gt;、重写onMeasure(),若想可以使用wrapContent属性则需重写此方法。若有必要还要加入padding修正代码。<br>　　4&gt;、动态效果。添加线程，线程中对坐标变量或颜色等属性进行循环变化（可充分利用Random对象的nextXXX()方法生产随机数），用包裹好的sleep()方法实现动态可见。线程中逻辑代码结束后调用postInvalidate()方法该方法会自动调用一次onDraw()。最后在onDraw()中创建该线程的对象，开启线程。</p>
<h2 id="2、继承ViewGroup。"><a href="#2、继承ViewGroup。" class="headerlink" title="2、继承ViewGroup。"></a>2、继承ViewGroup。</h2><h2 id="3、继承特定的View。"><a href="#3、继承特定的View。" class="headerlink" title="3、继承特定的View。"></a>3、继承特定的View。</h2><h2 id="4、继承特定的ViewGroup。"><a href="#4、继承特定的ViewGroup。" class="headerlink" title="4、继承特定的ViewGroup。"></a>4、继承特定的ViewGroup。</h2><h2 id="5、添加样式属性。"><a href="#5、添加样式属性。" class="headerlink" title="5、添加样式属性。"></a>5、添加样式属性。</h2><ul>
<li>定义。<br>　　xml中定义样式：比如要想设为属性的值是A，在res-values文件中新建一个xml文件，添加<declare-styleable>标签，里面先设置name（自定义view类名），里面再添加<attr>标签，里面设置name（样式属性名）和format（样式属性类型如reference,dimension,color和基本数据类型等）两个值。</attr></declare-styleable></li>
<li>布局。<br>　　layout中添加样式属性：首先引入命名空间。xmlns:iOS=”<a href="http://schemas.android.com/apk/res-auto&quot;。然后即可在下面标签中设置属性。iOS:name名=&quot;值" target="_blank" rel="external">http://schemas.android.com/apk/res-auto&quot;。然后即可在下面标签中设置属性。iOS:name名=&quot;值</a>“</li>
<li>解析。<br>　　最后进入自定义view类中的两个参数的构造方法进行解析。用context的obtainStyledAttributes()方法创建一个TypedArray对象。方法的两个参数分别是attrs和R.styleable.自定义view名。接着用该对象调用getInt()方法返回值赋给样式属性变量，两个参数分别是“R.styleable.自定义view名_样式属性名”和样式属性默认值。最后释放TypedArray,调用recycle()方法即可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/自己制作美美的View界面/" data-id="cj2n6xnuh001bvdpd1ruhx8pw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于android中的多线程和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/关于android中的多线程和线程池/" class="article-date">
  <time datetime="2016-04-03T10:01:50.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/关于android中的多线程和线程池/">关于android中的多线程和线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　首先get两个帮助测试时可以清晰了解线程动向的方法：Thread.currrentThread.getName() 显示当前线程。Thread.isAlive() 判断线程生命周期，只有新建和死亡两个阶段返回false。Runtime.getRuntime().availableProcessors() 显示CPU个数，可以依据这个创建线程个数。</p>
<p>　　接着区分几个概念：<br>　　<strong>并发与并行</strong>：多条指令在多个处理器上同一时刻执行为并行，多条指令在快速轮换执行为并发。并发在宏观上表现类似于并行。一个CPU同时只能执行一个进程（即并行数小于等于CPU数）。<br>　　<strong>程序、进程与线程</strong>：程序是静态指令集和，进程是正在活动的指令集和，有生命周期和各种状态。线程是进程的执行单元，类比于进程和操作系统的地位。主线程是随着进程被创建一起创建的。进程之间不能共享内存而线程之间可以。</p>
<hr>
<p>　　下面分别讨论下线程的生命周期，线程的几种形态，和线程池三个方面。</p>
<h1 id="一、线程的生命周期："><a href="#一、线程的生命周期：" class="headerlink" title="一、线程的生命周期："></a>一、线程的生命周期：</h1><h2 id="1、五个生命周期"><a href="#1、五个生命周期" class="headerlink" title="1、五个生命周期"></a>1、五个生命周期</h2><ul>
<li><p>1&gt;<strong>新建(new)</strong>。new出一个线程开始。</p>
</li>
<li><p>2&gt;<strong>就绪(runnable)</strong>。start()方法执行后开始。java虚拟机会为其创建方法调用栈和程序计数器。不能改成调用run()方法来启动，因为这样系统就会把线程对象当做普通对象，把run()当做一个普通方法而不是线程方法来处理。就绪之后并不是马上执行，而会稍等一小段时间（时间长度由底层平台控制），若想让它立即运行，只需让主线程sleep(1)睡眠1毫秒。</p>
</li>
<li><p>3&gt;<strong>运行(running)</strong>。就绪的线程随后开始执行run()，然后通过JVM的线程调度器决定（不可控）让它进入运行状态。如果底层平台采用“抢占式调度策略”（桌面和服务器操作系统），即每个线程轮流执行一小会儿（次序由线程优先级决定）。若是“协作式调度策略”（手机等小型设备），必须等该线程通过yield()活sleep()主动放弃所占资源，其中yield()回到就绪状态，sleep()进入阻塞状态。</p>
</li>
<li><p>4&gt;<strong>阻塞(blocked)</strong>。五种情况会进入阻塞，同样五种方法可以解除阻塞回到就绪（不能直接回到运行），这部分放到后面。</p>
</li>
<li><p>5&gt;<strong>死亡(dead)</strong>。run()或call()执行结束后自然死亡。或者调用线程的stop()手动死亡。或者抛出exception/error非正常死亡。死亡的线程不可以重新start()。</p>
</li>
</ul>
<h2 id="2、进入阻塞和阻塞解除"><a href="#2、进入阻塞和阻塞解除" class="headerlink" title="2、进入阻塞和阻塞解除"></a>2、进入阻塞和阻塞解除</h2><p>　　运行时的任务<strong>进入阻塞</strong>的五种情况：</p>
<ul>
<li>线程调用sleep()方法主动放弃所占资源。</li>
<li>线程调用了一个阻塞式IO方法。</li>
<li>线程试图获得一个同步监视器。</li>
<li>线程在等待某个notify。</li>
<li>程序调用了线程的suspend()将线程挂起。</li>
</ul>
<p>　　<strong>解除阻塞</strong>回到就绪的五种情况：</p>
<ul>
<li>sleep()方法时间到。</li>
<li>阻塞式IO方法已经返回。</li>
<li>成功获得了同步监视器。</li>
<li>其它线程发送了notify。</li>
<li><p>程序调用了挂起的线程的resume()恢复方法。</p>
<p>  <img src="http://7xs17a.com1.z0.glb.clouddn.com/135658248.jpg.bmp" alt="1"></p>
</li>
</ul>
<h1 id="二、线程的的几种形态："><a href="#二、线程的的几种形态：" class="headerlink" title="二、线程的的几种形态："></a>二、线程的的几种形态：</h1><ul>
<li>Thread</li>
<li>AsyncTask(底层线程池),</li>
<li>IntentService(底层直接用线程),是一种服务不是后台线程，优先度高不易被杀死。</li>
<li>HandlerThread(底层直接用线程)。</li>
</ul>
<h1 id="三、线程池。"><a href="#三、线程池。" class="headerlink" title="三、线程池。"></a>三、线程池。</h1><p>　　除非线程数小于等于CPU核心数，否则线程不可能做到绝对的并行，只会通过时间片轮转的方式调度每个线程。因此需要一个线程池存放线程的缓存，否则大量线程的创建和销毁会消耗大量时间，入不敷出。</p>
<h2 id="1、ThreadPoolExecutor的六个构造参数"><a href="#1、ThreadPoolExecutor的六个构造参数" class="headerlink" title="1、ThreadPoolExecutor的六个构造参数"></a>1、ThreadPoolExecutor的六个构造参数</h2><p>　　线程池类ThreadPoolExecutor实现了接口Executor（事实上Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService，而ThreadPoolExecutor其实是实现了ExecutorService接口,关系见最下方图片）。其构造器共接受六个参数：</p>
<ul>
<li>int corePoolSize,</li>
<li>int maximumPoolSize,</li>
<li>long keepAliveTime,</li>
<li>TimeUnit unit,</li>
<li>BlockingQueue<runnable> workQueue,</runnable></li>
<li>ThreadFactory threadFactory.</li>
</ul>
<p>　　分别是<strong>核心线程数</strong>，<strong>最大线程数</strong>（到达最大线程数后后续任务被阻塞），<strong>闲置超时时长</strong>（非核心任务闲置超过该参数就会被回收），<strong>时长单位</strong>（是一个枚举），<strong>任务队列</strong>（通过线程池的execute方法提交的Runnable对象会存在这里），<strong>线程工厂</strong>（可创建新线程）。</p>
<p>　　拿熟悉的AsyncTask来说，它里面有两个线程池，分别是<strong>SerialExecutor</strong>和<strong>THREAD_POOL_EXECUTOR</strong>，前者用于任务的排队，后者是真正的执行任务。查看AsyncTask源码可以看到它对THREAD_POOL_EXECUTOR这个线程池进行了配置，这些参数的配置情况如下：</p>
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;
private static final ThreadFactory sThreadFactory = new ThreadFactory() {
private final AtomicInteger mCount = new AtomicInteger(1);

public Thread newThread(Runnable r) {
  return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
}

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =new LinkedBlockingQueue&lt;Runnable&gt;(128);

public static final Executor THREAD_POOL_EXECUTOR= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre><p>　　ThreadPoolExecutor线程池执行任务时规则如下：1、线程池中线程数小于核心线程数，则直接启动一个核心线程。2、线程数超过核心线程数，进入任务队列排队。3、任务队列满了，启动一个非核心线程存放下一个任务。4、达到线程池最大线程数了，任务被拒绝。同时RejectedExecutionHandler会调用rejectedExecution()来通知调用者。</p>
<p>　　另外关于keepAliveTime参数，它是针对非核心线程超时情况，核心线程默认会一直存活。若想使得闲置的核心线程同样在keepAliveTime到时时被回收，只需将ThreadPoolExecutor的<strong>allowCoreThreadTimeOut</strong>参数设为true即可。</p>
<h2 id="2、四种常见线程池。"><a href="#2、四种常见线程池。" class="headerlink" title="2、四种常见线程池。"></a>2、四种常见线程池。</h2><p>　　它们都是通过Executors类（注意不是Executor接口，Executors类的作用正是创建线程池）的方法newXXXXThreadPool来创建，将线程放入线程池的操作都是通过它们自己的对象调用execute()/submit()方法（两者的区别留到以后讨论..），参数中传入线程名。四种线程池中FixedThreadPool，CachedThreadPool，SingleThreadExecutor是实现的ExecutorService接口（创建对象是创建ExecutorService的对象），ScheduledThreadPool是实现ScheduledExecutorService接口。</p>
<h3 id="1-gt-、FixedThreadPool"><a href="#1-gt-、FixedThreadPool" class="headerlink" title="1&gt;、FixedThreadPool."></a>1&gt;、FixedThreadPool.</h3><p>　　只有核心线程且数量固定，线程空闲时不会被回收，任务队列没有大小限制。</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><h3 id="2-gt-、CachedThreadPool"><a href="#2-gt-、CachedThreadPool" class="headerlink" title="2&gt;、CachedThreadPool."></a>2&gt;、CachedThreadPool.</h3><p>　　核心线程数0，非核心线程数任意大。超时时长60秒即被回收。因为最大线程数无限所以其SynchronousQueue队列不需要放入任务。适合大量的小任务。</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><h3 id="3-gt-、ScheduledThreadPool"><a href="#3-gt-、ScheduledThreadPool" class="headerlink" title="3&gt;、ScheduledThreadPool."></a>3&gt;、ScheduledThreadPool.</h3><p>　　核心线程数量固定，非核心线程任意大。超时时长0意味着闲置立马收回。适合定时任务和周期任务。</p>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
</code></pre><h3 id="4-gt-、SingleThreadExecutor"><a href="#4-gt-、SingleThreadExecutor" class="headerlink" title="4&gt;、SingleThreadExecutor."></a>4&gt;、SingleThreadExecutor.</h3><p>　　只有一个线程且是核心线程。意义在于将多个线程统一到同一个线程中。</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre><p>　　<br>　　下面是四种线程池的调用方法示例：</p>
<pre><code>Runnable r=new Runnable() {
    @Override
    public void run() {
        //do something
    }
};

ExecutorService ftp= Executors.newFixedThreadPool(4);
ftp.execute(r);

ExecutorService ctp= Executors.newCachedThreadPool();
ctp.execute(r);

ScheduledExecutorService stp= Executors.newScheduledThreadPool(4);
stp.execute(r);

ExecutorService sintp= Executors.newSingleThreadExecutor();
sintp.execute(r);
</code></pre><p>　　最后是完整的线程池的类体系结构，图中清晰地展示了之前用到的Executor,Executors,ExecutorService,ScheduledExecutorService,ThreadPoolExecutor,ScheduledThreadPoolExecutor之间的关系。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/Executor-class_2.png" alt="2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/关于android中的多线程和线程池/" data-id="cj2n6xntz000yvdpd77jxjn1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-漫谈android异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/03/漫谈android异步/" class="article-date">
  <time datetime="2016-04-02T16:38:51.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/漫谈android异步/">漫谈android异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　Google在Browser中大量的使用了异步任务作为处理耗时的I/O操作，比如下载文件、读写数据库等等。在android中，耗时任务放在主线程会导致阻塞，而android的UI是单线程的，若使用了多线程操作一个UI很容易导致反向加锁和死锁问题，所以只有主线程能操作UI（同样只能在子线程操作网络访问，否则会抛出NetworkOnMainThreadException异常），子线程若想借助主线程影响UI，就是今天要讨论的异步操作。经过学习积累，总结异步实现的方法有如下几种。</p>
<p>　　<strong>1.Thread-Handler消息传递机制</strong><br>  　　首先是定义并启动一个子线程。继承Thread类和实现Runnable接口都是可以的，总之是要重写它们的run()方法，在里面运行子线程任务。<br> 　　 Message负责线程之间传递消息。包括what，arg1,arg2（携带整型数据）,obj（携带object对象）四种字段。Handler拥有的setMessage（）和handlerMessage（）方法用来传递和接受消息。<br>  　　MessageQueue消息队列，存放消息。Looper拥有的loop（）方法会无限循环传递MessageQueue中的一条条消息。Looper是与Handler一一对应的。一个线程中只有一个MessageQueue，也只有一个Looper。<br>  　　所以流程大致是，需要进行后台任务的Thread子线程中创建Message对象并为其赋予一个专属字段，用Hadler对象调用setMessage（）方法将消息发送到MessageQueue队列中。接着主线程中已经建好的Handler对象所对应的Looper会负责读取消息，回掉dispatchMessage()方法将消息传给Handler，Handler中重写父类的handlerMessage()方法，其参数接受一个Message对象，在方法体中判断Message对象字段匹配后执行UI操作。<br>  　　缺点：有时可能消息队列阻塞或其他原因无法准确的使用。</p>
<p>　　<strong>2.AsyncTask机制</strong><br>  　　首先要明确AsyncTask机制的实现原理也是基于消息传递机制的，它封装了Thread和Handler。<br>  　　AsyncTask是抽象类，第一步当然就是创建子类继承它，继承时需要制定三个泛型参数，分别是Params–需要传入的参数比如HTTP请求的URL，Progress–后台执行时的进度如一个表示百分数的数组，Result–执行完毕后的Boolean类型结果。接着是重写父类的四个方法。<br>  　　onPreExecute()。执行前的初始化，可执行UI任务，比如show一个ProgressDialog。<br>  　　doInBackground()。我们的子线任务就是在这里执行，不能执行UI操作。与第三个方法互动—可以用pulishProgress()方法讲任务进度传递出去。与第四个方法互动—返回一个boolean类型值，表示任务成功结束否。<br>  　　onProgressUpdate()。如果上一个方法传递了任务进度，就用这个方法来显示（该方法是被UI主线程调用）。参数一般是不定长度的Interger数组，即Interger…i (三个点表示不定长度参数，i相当于一个int数组)，利用ProgressDialog的setMessage()将进度数组显示在进度条上。<br>  　　onPostExecute()。任务结束后的收尾。可以dismiss()那个进度条。参数是第二个方法返回的Boolean值，因为也是被UI现成调用所以可以将boolean结果显示出来。参数也可以是第二个方法返回的String值，获取到将异步操作返回的结果。<br>  　　四个方法不能手动去调用，在主线程中想启动任务，要在主线程中创建任务对象后，调用execute（）即可。<br>      缺点：并不适合特别耗时的后台任务。</p>
<p>　　<strong>3.runOnUiThread方法</strong><br>  　　在thread子线程的run()中若想进行UI操作，直接调用Activity的一个方法runOnUiThread（），它同Thread的构造器一样接受一个Runnable参数，于是可以用同样的匿名类方式写，在重写的run()方法中进行UI操作即可。之后没有.start()。</p>
<pre><code>runOnUiThread(new Runnable() {
public void run() {
 //do something;}}); 
</code></pre><p>　　<strong>4.Handler/view的post(Runnabel r)方法</strong><br>  　　就是post一个runnable对象到消息队列，用来更新UI。用法类似于3，在子线程中创建一个Handler对象（或一个View对象）并调用post()方法，其参数是Runnable对象，匿名类并重写run()方法，在里面UI操作。</p>
<pre><code>handler.post(new Runnable(){
public void run() {
//do something;}});
</code></pre><p>　　目前知识储备中暂时只有这四种，等get到新技能再回来补充。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/03/漫谈android异步/" data-id="cj2n6xnu40015vdpdq6cogf5x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ssd初体验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/25/ssd初体验/" class="article-date">
  <time datetime="2016-03-25T15:52:52.000Z" itemprop="datePublished">2016-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/25/ssd初体验/">ssd初体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　今天的主角是这款去年的明星产品，镁光(crucial)MX200。观望许久售价终于跌破百分之二十，果断入手。</p>
<p>　　曾在两兄弟BX100 500G版和MX200 250G版之间小犹豫，考虑到最近两年不仅是大型单机，几乎算是已经告别了一切游戏，仅装软件250G应该够用了，另外BX100比起MX200削减的功能有AES硬件加密和断电保护，但这些都不是最致命的，美光居然舍弃了自家主控搭配了Silicon Motion(慧荣)的主控芯片，那我买美光的意义何在。</p>
<p>　　横向比完再来纵向比比，和之前的型号MX100相比区别之一是闪存芯片，虽同样是MLC颗粒，MX100的128G版本是20nmMLC，剩下两个版本和MX200所有版本都是16nmMLC。关于制程工艺的发展真可谓日新月异，五年前还是34nm/25nm的天下，后来英特尔和美光推出20nm工艺的MLC NAND,三星推出21nm,东芝推出19nm，人们还在担心随着制程技术的提高擦写次数可能会跌破300PE，如今16nm上阵而擦写次数似乎保持住了。究其原因，制程越先进，一颗cell(晶圆)上能生产出更多芯片，闪存颗粒中用于读写的氧化物层会越薄，每一次完整的P/E，都会对氧化物层造成损耗，加上电子易流失易蒸发，于是能承受的P/E次数也会越少。这也是现在闪存市场上MLC与TLC争夺的焦点所在。TLC能做到3bit/cell，速度慢寿命短，最多没有达到1000PE的，所以一般只存在于U盘中。但如今TLC有在SSD领域赶超MLC之势，原因就在于更低的成本但又能获得更高的容量，这对于一般以容量作为唯一标准的普通老百姓来说是没有理由拒绝的。目前TLC已经接近一半市场份额，主要是三星在推，结合3D NAND技术在做多TLC，其evo系列tlc甚至卖的和mlc一样贵。</p>
<p>　　SSD由主控、闪存、缓存、固件等四大部分组成，说完内存颗粒，刚才还提到了主控。MX200选用的是marvell 88SS9189主控，使用marvell 主要是Lite-on（浦科特）和Micron（镁光），英特尔用sandforce的主控牺牲性能延长寿命，OCZ(饥饿鲨)的barefoot(大脚)主控燃烧寿命获取性能。三星和东芝都有自己的主控，性能也都还可以。其他的sm(慧荣)和jm(Jmicron智微)什么的主控，就比较低端了。</p>
<p>　　<strong>参数一览：</strong><br>　　Marvell 88SS9189主控，八颗美光16nm MLC闪存颗粒，2.5英寸、7mm机身，全系列MX200的最高连续读写速度均为：555/500 MB/s，最高随机读写速度均为：100k/87k IOPS。DWA动态写入加速技术，256位AES加密支持，对R.A.I.N的支持。动态写入加速(AWA)，这是美光自己的SLC缓存加速方案。缓存大小是动态的，根据硬盘里的数据量而定，空盘就是纯粹的SLC模式，随着可用空间的减少缓存也越来越小。</p>
<p>　　<strong>下面回顾下安装流程：</strong></p>
<p>　　取出机械硬盘，自带的是日立HTS541010A9E680，日立从12年起标签上的标志由Hitachi改成了HGST，HGST与WD(西部数据)目前为WDC旗下独立营运的两家子公司，拥有不同的品牌和产品线，这也是美国反垄断法的功劳。这块硬盘是6Gb/s的SATA接口，5400转，8M缓存，1T容量。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_175118.jpg" alt="1"><br>　　<br>　　拿出我们的MX200，铝制外壳，风格是老式样，深色贴纸银色字条，背面贴着铭牌,上面内容包括有：型号：CT250MX200SSD1，256GB容量，SATA3 6GB /S接口，额定电压5V，0.7A的电流。各种认证：CE,ATA标准，FC，可回收利用环保等等。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_175607.jpg" alt="2"></p>
<p>　　有心拆解一探内部构造，但是铝制外壳的无螺丝卡扣非常紧，怕暴力拆解直接报废。只能在网上找拆解评测过过眼瘾了。单面电路布局，主要核心用料都在一面。左面是8个16NM MLC的NAND颗粒共250GB容量，右下角较大的就是前面聊过的Marvell主控，上面是一片DDR3缓存芯片，缓存这东西在机械硬盘上意义重大，固态硬盘中作用就大打折扣了。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/s_af4c0316769f4cb8b1b39c4470d5b316.jpg" alt="3"></p>
<p>　　两个硬盘的对比<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_175407.jpg" alt="4"></p>
<p>　　由于光驱位是SATA2接口，装固态会限制其性能。所以选择把机械硬盘安在光驱位硬盘托架放入光驱位。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160326233429.jpg" alt="5"></p>
<p>　　接下来也很简单，开机后用分区助手6.2将系统盘迁移到固态盘，注意迁移前检查错误，迁移后分区对齐–4K对齐，重启时迁移自动完成。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_200315.jpg" alt="6"></p>
<p>　　然后是BIOS设置。华硕本本一律开机时狂点F2，进入后先将SATA Mode Selection开启AHCI，由于这里系统本来就是SATA串口传输模式所以是开着的。然后Boot启动顺序将固态放在首位，这里第二位的是我自装的黑苹果系统。<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_213345.jpg" alt="7"><br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_213907.jpg" alt="8"></p>
<p>　　开机后进行测试。ASSSD得分如下。第一行seq是持续测试，读写速度在500左右。第二行4K测试即随机单队列深度测试，seq是1G大小的文件读写测试，4K只是一个小文件，所以4K测试结果相比之下在平常使用时意义更大。第三行64队列4K测试，传输数据量同seq一样是1G，但是是以4KB为单位在64个16MB的文件中读取测试。最后一行数据存储时间测试。　　<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/20160324_221622.jpg" alt="9"></p>
<p>　　最后一项Crystaldiskinfo测试，将机械硬盘也放出来作对比，完事收工！<br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160325235047.png" alt="10"><br>　　<img src="http://7xs17a.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160325235041.png" alt="11"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/25/ssd初体验/" data-id="cj2n6xntt000rvdpdor55egpa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hardware/">Hardware</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hardware/">Hardware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/movie/">movie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/science/">science</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Code/" style="font-size: 20px;">Code</a> <a href="/tags/Hardware/" style="font-size: 10px;">Hardware</a> <a href="/tags/code/" style="font-size: 16.67px;">code</a> <a href="/tags/movie/" style="font-size: 13.33px;">movie</a> <a href="/tags/science/" style="font-size: 10px;">science</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/19/github模式/">MVP模式</a>
          </li>
        
          <li>
            <a href="/2016/09/17/跟投设置页面开发笔记/">跟投设置页面开发笔记</a>
          </li>
        
          <li>
            <a href="/2016/09/14/获取屏幕数值/">获取屏幕数值</a>
          </li>
        
          <li>
            <a href="/2016/09/11/支付宝支付和微信支付SDK的使用/">支付宝支付和微信支付SDK的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>