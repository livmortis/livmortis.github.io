[{"title":"eventbus","date":"2017-05-13T15:51:21.000Z","path":"2017/05/13/eventbus/","text":"Eventbus可代替：handler/message、intent、broadcast 一、基本用法1.建立javaBean类 用来存放发送和接收的消息的实体类。 2.接收方 1&gt; 注册和解注册 onCreate()中EventBus.getDefault().register(this); onDestroy()中EventBus.getDefault().unregister(this); 2&gt; 新建接受方法 加入注解：@Subscribe(threadMode = ThreadMode.XXX) 接受方法参数为javaBean类对象。该方法必须是public。 3&gt;ThreadMode分 四种：Main，background，async，posting 3.发送方 新建javaBean类对象，通过构造器传入数据。 Event.getDefault().post(javaBean类对象) 二、粘性事件用法1.与基本用法区别 基本用法接收方先注册，发送方发送的一瞬间接受方立马会接收到；粘性事件先发送方先发送，接收方注册的一瞬间接受消息，不注册则发送方已发送的消息会一直存在于虚空中无法接受到。 2.发送方 EventBus.getDefault().postSticky(javaBean对象) 3.接收方 加入注解：@Subscribe(threadMode = ThreadMode.XXX, sticky = true) 写接受方法 4.接收方注册和解注册 注册：EventBus.getDefault().register(this) 解注册：EventBus.getDefault().removeAllStickyEvents() 注意点： subscriber修饰的方法名字可以随便起，但一定得是public。 两个activity之间跳转，要用粘性事件，普通的不行。 threadmode为main和posting的时候，自定义方法里才可以写操作ui的逻辑。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"MVP模式","date":"2016-09-19T15:18:19.000Z","path":"2016/09/19/github模式/","text":"一、与MVC的区别 mvp的View是xml文件和activity；mvc的View是xml，Controller是activity。 Modle都是业务逻辑和实体类，如处理数据，网络请求等。 mvp对Model层和View层的解耦做得更好。 mvp的View和Presenter之间交互通过接口，所以为View编写个接口Iview。 mvp的Model和Presenter之间交互通过接口，所以为Model编写接口Imodel。 二、demo制作。 实现伪登陆界面，判断账号密码是否正确，对应显示不同toast，并且正确时textview显示一行文字。 View包 1.创建Iview接口。 view的职责有textview添加文字、获取edittext文字、清空edittext文字、显示和隐藏progressbar。 所以创建7个抽象方法。 String getViewAccount(); void clearViewAccount(); String getViewPass(); void clearViewPass(); void showViewBar(); void removeViewBar(); void addViewText(String s); 2.创建View类并实现Iview。 正是MainActivity。 1&gt;、纯view逻辑 重写7个方法，除了addViewText()其余全是只有view逻辑。 2&gt;、与presenter交互（访问presenter）。 创建presenter对象，将this从构造方法中传过去（因为ipresenter也要访问view）。 addViewText()中textview所set的文字来自于present。 登陆和清空两个点击事件中，是业务逻辑而不是界面展现，所以直接调用presenter的performLogin()和performClear()方法。 Modle包 1.实体类bean存放账号密码。 2.创建Imodle接口。 modle的职责有控制textview要展示的数据、网络请求判断账号对错。 所以创建2个抽象方法。 void judgement(String ac, String pa, Model.SuccessCallback successCallback,Model.FailCallback failCallback); String queryData(); 3.创建Modle类并实现Imodle modle与presenter交互只是presenter单方面访问modle，所以modle中不需要创建presenter对象。 1&gt;、judgement()方法。 新建子线程进行网络请求，再在类中建两个回调接口，judgement()中进行账号对错核对（或发送请求给网络接口处理），再将成功失败结果回调出去。 2&gt;、queryData()方法。 处理数据，将数据返回。 preseter包 1.创建perfomLogin()和performClear()两个方法，体现了preseter层的职责是实现view页面的功能。 2.创建Imodle和Iview两个接口的对象，前者用Modle类构造器创建，后者不能创建对象，用从Activity中传入的this作为对象。 3.与modle交互。 performLogin()方法中调用judgement()方法，新建主线程（注意新建handler不能在子线程中），得到回调的结果（登陆成功与否）。 4.与view交互。 1&gt;、在调用的judgement()方法的成功回调中，调用view的去除progress方法removeViewBar()，和view的为textview赋值方法addViewText(String s)（传入的参数是model的queryData()的返回值，这一步完成了数据从model向view的转移，体现了model操控数据的功能）。失败回调中同样去除progressbar。 2&gt;、performClear()方法中调用view的clearViewAccount()和clearViewPass()两个方法。实现clear功能。 ps: 1.子线程不能创建Handler对象。 2.不能创建activity对象。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"跟投设置页面开发笔记","date":"2016-09-17T15:28:16.000Z","path":"2016/09/17/跟投设置页面开发笔记/","text":"长城证券爱投汇项目中开发”跟投设置”页面过程中的笔记 一、控件1.TextView相关 1&gt;、想要类似radiobutton setClickable()；setEnable()；setFocusable() 主要还是setSelected() 2&gt;、ImeOptions属性 控制软键盘右下角按键。 actionNone : 回车键，按下后光标到下一行 actionGo ： Go， actionSearch ： 一个放大镜 actionSend ： Send actionNext ： Next actionDone ： Done，隐藏软键盘，即使不是最后一个文本输入框 2.RadioButton和RadioGroup相关 两行radiobutton还是改用textview，因为每个radigroup只能排一个方向，不同group控制单选很难（如果互相clearCheck()效果不好）。 1&gt;、 RadioGroup.setOnCheckedChangeListener().接口的onCheckedChanged()方法，第一个参数是radiogroup暂时没有使用，第二个参数便是每个radioButton控件的id。 2&gt;、将前方加圆点样式改为radiobutton背景变色样式。 先将radiobutton的button属性改为”@null”，去掉了前面的圆点；再将背景设为有selected属性的selector文件；最后代码里setSelected(true/false)来控制被选背景颜色是否显示。selector文件如下： &lt;selector xmls:android=&quot;http://schemas.android.com/apk/res.android&quot;&gt; &lt;item android:drawable=&quot;@drawable/XXX&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/XXX&quot; android:state_selected=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/XXX&quot; android:state_checked=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawableXXX&quot;/&gt; &lt;/selector&gt; 3&gt;、radiobutton.setChecked(false)和radiogroup.clearCheck()方法。 两个方法都能取消选择，但是都会重新走一遍onCheckedChanged()方法。如果此时onCheckedChanged()方法中有不想让执行的代码，可以用TAG选择过滤。 3.spinner相关 1&gt;、制作 ArrayAdapter adapter = new ArrayAdapter(getContext(),子项布局,显示字符串数组) spinner.setAdapter(adapter) 2&gt;、监听 spinner.setOnItemSelectedListener(new OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view , int position, long id) { //adapterView.getId()表示多个spinner中switch/case哪个。adapterView.getItemAtPosition(position)表示获取某个子项的文字。 //position表示选择了第几个子项，从0开始计算。 } @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) { // 暂时不用该方法 } }); 3&gt;、设置默认选中 spinner.setSelection(n)，n从0开始。 4.edittext相关 1&gt;、限制密码类型 xml: android:inputType=”textPassword” java: myEditText.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD); 2&gt;、限制数字 xml: android:digits=”0123456789” 3&gt;、限制小数 xml: android:inputType=”numberDecimal” 4&gt;、监听内容变化 editText.addTextChangedListener(new TextWatcher(){ public void onTextChanged(CharSequence s,int start, int before, int count){} public void beforeTextChanged(CharSequence s ,int start,int count,int after){} public void afterTextChanged(Editable s){} }); 取消监听edittext.removeTextChangedListener(watcher)，可以用取消监听加增加监听两行代码包围一条edittext改变语句，让这条语句不被监听。 5&gt;、监听软键盘回车键事件 editText.setOnEditorActionListener(new OnEditorActionListener() { @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) { return false; } }); 6&gt;、点击空白处软键盘收回 将父布局设为clickable=true; java中在父布局的点击事件中加入： InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(v.getWindowToken(), 0); 这里v是onclick的参数，getSystemService是Context的方法。 二、屏幕适配1.横向居中 使linearlayout为matchparent；使linearlayout的gravity为center。 使linearlayout内部的textview的宽度为固定值，而不是wrapContent。 textview然后想让字居中不是使用padding，而是使gravity为center。 2.字体适配 values文件的dimens.xml文件中，新建多个dimens.xml(比如四个)，分别对应320dp,360dp,430dp,480dp的分辨率。 每个文件中设置各自的字体大小数值： &lt;resources&gt; &lt;dimen name=&quot;XXX&quot;&gt; Xdip &lt;/dimen&gt; &lt;/resources&gt; 对应数值：默认、320 = 10dip ； 360 = 11dip ；420 = 13dip ；480 = 14.5dip 模拟器预览框预览的是360dp-hdpi版本的。 320/360=8/9 420/360=7/6 480/360=4/3 3. 能使用gravity和center解决的，不用padding和margin。如果需要纵向margin，让外层布局margin，内层控件不要margin直接gravitycenter。而横向margin基本可以用weight来代替。 4.weight的使用 利用textview可以占位、空白View可以占位两项神器，一切横向布局都可以使用weight来解决，完美解决屏幕适配问题。 三、字符串计算并保留两位1.字符串转数字 Double.parseDouble(字符串) Float.parseFloat(字符串) Integer.parseInt(字符串) 数字转字符串最好用 String.valueOf(数字) 2.保留两位DecimalFormat d = new DecimalFormat(&quot;#.##&quot;) d.format(小数) 四、一个textview分段显示颜色/内容1.SpannableString spannableString = new SpannableString(字符串)； Pattern p = Pattern.compile(匹配的字段); Matcher m = p.matcher(spannableString); while(m.find()){ int start = m.start(); int end = m.end(); } spannableString.setSpan(new ForegroundColorSpan (getResouces().getColor(R.color.XXX)) , start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); 2.分段显示内容。 可用stringBuilder的replace()方法进行 五、java 整数/整数，该分数结果一定是整数，如果小于1就会变成0. 只需整数后面加.0，相除即可为浮点数。 六、TAG大法 利用TAG值来确定代码跳转来源。 举例：用TAG标记，是edittext的”内容改变监听”跳到radiobutton的onCheckedChanged()方法，还是正常走radiobutton的onCheckedChanged()方法。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"获取屏幕数值","date":"2016-09-14T13:40:35.000Z","path":"2016/09/14/获取屏幕数值/","text":"一、屏幕高度和宽度 DisplayMestrics类中有widthPixels和heightPixels两个变量，分别是宽度的像素和高度的像素。还有density密度。相乘即为高度和宽度。 1.获取DisplaymMetrix对象: 方法一：DisplayMetrics dm = new DisplayMetrics() etWindowManager().getDefaultDisplay().getMetrics(dm) 方法二：context.getResource().getDisplayMestrics() 2.调用像素和密度计算长度：int w = dm.widthPixels * dm.density int h = dm.heightPixels * dm.density 注意屏幕高度不是该页面总高度，是手机显示的当前页面的高度。 二、控件的高度和宽度。 view.getGlobalVisibleRect() 获取该控件的四个坐标值，坐标原点是整个屏幕的左上角。 view.getLocalVisibleRect() 获取该控件的四个坐标值，坐标原点是“可见范围内的”该控件的左上 参数是Rect的对象，方法效果是将控件的四个坐标传给Rect对象身上。 有了 rect对象，利用top,bottom,left,right值可以计算控件各种长度。 三、通过decorView获取各种顶层view高度和宽度。 1.decorView是window中最顶层view。获取方法：getWindow().getDecorViw()。 2.获取状态栏高度： decorview.getWindowVisibleDisplayFrame()，可以获得除状态栏外的所有区域。参数为Rect对象。区域的top值便是状态栏高度。 3.获取标题栏高度： getWindow().findViewById(Window.ID_ANDROID_CONTENT)，可以取得除状态栏和标题栏的所有区域，返回值直接是个rect，取top值，减去状态栏高度就是标题栏高度。 四、屏幕滚动 1.scrollview的scrollBy(x,y) 移动x,y的距离。 2.scrollview的scrollTo(x,y) 移动到x,y的位置。 五、改变控件高宽 view.setButtom() setTop() setLeft() setRight()。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"支付宝支付和微信支付SDK的使用","date":"2016-09-11T15:23:03.000Z","path":"2016/09/11/支付宝支付和微信支付SDK的使用/","text":"目前工作的项目(投顾业务)中已有微信支付功能，下一步是要加入支付宝支付，结合项目代码来总结下两种sdk的使用。 微信支付客户端——&gt;本地接口一、充值页面（DklcRecharge） 1.先getPaymentList()，从接口获取”支付列表”，并将其放入GPaymentlist实体类中。 2.从接口获得金豆选项view 3.点击支付事件：弹出一个PopWindow。 二、popwindow（PayPopWindow） 1.获取以下内容： 投顾ID，充值金额（GPaymentlist类的keyvalue变量），ip地址（分wifi和流量两种途径获取），交易类型（APP），body（GPaymentlist类的descr变量，并用UTF-8编码），金豆比率（GPaymentlist类的id变量）。 2.点击微信支付事件：调用自定义WeiXinPay类的requestPay()方法，将上述6个值传入。 三、请求接口，获取数据（WeiXinPay） 1.构造器中注册APP： 1&gt;.创建微信SDK“IWXAPI类”的对象：IWXAPI api = WXAPIFactory.createWXAPI(context，APPID(获取方法见下))。 2&gt;.调用微信SDK“IWXAPI类”的registerApp()方法，传入APPID。 3&gt;.APPID来源： 在微信开放平台填写包名和签名后可注册应用，注册应用后得到appid。 项目中写在了function.properties文件中——wx973da9dd05403d3e， 通过MiddlewareProxy.getFunctionManager().getProperty()方式获取，安卓原生获取方法是： Properties pro = new Properties(); InputStream is = context.getAssets().open(“function.properties”); pro.load(is); 2.向本地接口发送请求 判断完”是否安装微信”，”微信版本是否支持支付”之后，传入上述6个值开始发送请求 本地接口——&gt;客户端 3.处理数据 1&gt;.获取的数据放在实体类里，包括appid , partnerid , prepayid , sign , noncestr , tiemstamp 7个值。 2&gt;.新建SDK中的类PayReq的对象，将7个值放入该类的7个变量里 客户端——&gt;微信服务器 3&gt;.调用IWXAPI的sendReq()方法，将PayReq对象传入。完成。 支付宝支付客户端——&gt;本地接口一、充值页面 同微信 二、popwindow 基本同微信。 将n个本地值拼成url，在子线程中传给项目类MobileSecurePayer的自定义方法requestOrderInfo()方法中。 三、请求接口，获取数据（MobileSecurePayer类） * 1.请求接口 requestOrderInfo()中进行HttpURLConnection网络请求，返回的json中应该包括了如下数据： 本地接口——&gt;客户端 body商品描述 ，partner合作商ID , seller商户支付宝号 , sign商户私钥签名 ， out_trade_no外部订单号 ， notify_url支付宝给本地接口的url ， total_fee价格 ， errno错误码 ， subject 9个参数。 * 2.传递数据 将数据从子线程传出到主线程。新建Message对象，what字段设为4，obj字段设为获得的json数据，sendMessage()。 四、解析数据 1.Handler接收数据 Handler接口的方法handleMessage()中先判断what字段是否为4，然后提取出obj字段的json数据。 2.解析出订单信息 json数据传递给项目方法getOrderInfo()，在里面对9个变量加入&amp;和\\进行拼接成一个stringBuilder，这就是订单信息。 客户端——&gt;支付宝服务端五、提交订单信息 1.开启支付宝的“安全支付服务” 先在外部newServiceConnection接口，重写onServiceConnected()和onServcieDisconnected()方法，前者：先加同步锁，再mAlixPay=IAlixPay.Stub.asInterface(service), 后者：mAlixPay=null。 在项目方法pay()中bindService()。 2.开启子线程 3.try中提交 1&gt;.先判断同步锁。 2&gt;.为安全支付服务注册回调。 mAliPay.registerCallback(回调对象)。 3&gt;.正式提交，调用mAliPay.pay()，参数传入订单信息。 4&gt;.发送交易结果，新建Message对象，what字段设为1，obj字段设为SDK的pay()的返回值。利用刚才的回调对象sendMessage()。 4.catch中提交 同样的新建Message后发送，obj字段为e。 5.finally中解除回调 + 取绑服务 mAlixPay.unregisterCallback(回调对象)。判断若在绑定，执行unbindService()。 支付宝服务端——&gt;客户端六、Handler接收数据 1.Handler接口的方法handleMessage()中先判断what字段是否为1。 2.新建签名检验类ResultChecker对象，构造函数中传入obj字段。 3.ResultChecker对象调用getResultStatus()，获得支付状态，支付状态若等于9000，表示支付成功。 4.清除handler,lock,context,serviceConnection,callback。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"2016.8.12晚观星","date":"2016-08-25T14:49:02.000Z","path":"2016/08/25/2016-8-12晚观星/","text":"背景：8月12日晚至13日凌晨，英仙座流星雨，小和山工大朝北寝室，可见度较好凌晨一点起可看到昴宿星团的六颗星，观测时间0点到3点，以仙后座为参考位置 1. 0点开始，北半天正中间是仙后座（王良四星等2.2），开口朝西（此处均假设寝室阳台朝向正北），西边是倒房子型五星仙王座（天钩五星等2.45），仙后和仙王的西南方向，或仙后的M反向延长线与M中心星的连线，向开口方向的延长线上可看到北极星，亮度较弱（星等1.95）。 东北处是英仙座，天船三（1.75），今天流星雨的主角。 抬高仰角，仙后座西南方向一颗亮星为天津四（星等1.25），所在的天鹅座气势磅礴，大鹏展翅霸占天空。形似翼手龙。天津四与右翼中翅连线延长线可看到最亮的织女一（星等0）。 高仰角。仙后座东南方向是半十字形状的仙女座，往东三角座（锐角等腰），往东白羊座（四星折线，间距递增）。 2. 一点开始，昴宿星团和金牛座(毕宿五星等-0.85)五星等边三角型升起。 3. 两点开始，御夫座(五车二星等-0.54)升起于东边，仙后仰角抬高天鹅降低，整体星空围绕北极星逆时针转动。 东边出现御夫座只手遮天，英仙座的天船三厚积薄发。 西边夏季大三角闪耀，天津四慢慢褪去光芒织女座照亮全场，河鼓二带着河鼓三在最西边形单影只，西南部由南鱼座的北落师门统领一方，与大三角组成畸形”大平行四边形”。 4. 三点此时天空目视星等排名。 五车二=织女星&gt;毕宿五&gt;河鼓二&gt;北落师门&gt;天津四&gt;天船三&gt;五车五 流星记录：0点06分第一颗，小熊座以北自动向西，短快暗。0点39分最长的一颗，仙王座主星和北极星之间自动向西走了接近20度。1点34最亮一颗，红色，仙后座第二主星划向王良四，星等远超当时老大织女，-5以上，残影两秒以上。一共看到十颗左右（0点到1点看到五颗：6分、18分、27分、39分、44分），晚两点左右频率极高，没再花时间看。","tags":[{"name":"science","slug":"science","permalink":"http://yoursite.com/tags/science/"}]},{"title":"AS实用插件总结","date":"2016-07-31T16:24:36.000Z","path":"2016/08/01/AS实用插件总结/","text":"setting的plugins中可以安装和卸载插件 一、GsonFormat–将json数据自动提取到实体类 空白处右键选generate-GsonFormat，将json数据拷贝进来，修改好后即可新建实体类将json放入。 二、ButterKnife–将布局控件自动生成butter代码到java代码中 1、先在module的gradle里依赖：compile ‘com.jakewharton:butterknife:7.0,1’并sync now一下。 2、在Activity的setcontentview方法中，点选参数中的layout布局名，右键generate butterknife injections，即可插入butterknife代码。 三、Android Code Generator–将布局控件自动关联到java代码中 xml中右键generate Android code—Activity 创建正常的java关联代码 四、Android Selectors Generate–快速生成selector文件，设置点击样式改变。 1、将button点击前后的两张图片XXX_normal.png和XXX.pressed.png放入drawable中，右击drawable，generate android selectors（最好在project视图下），即可生成一个将两张图片添加到item标签后的selector文件XXX_selector.xml。 2、layout的控件调用@drawable时，将selector文件名写上去，便可自动将控件点击前后的显示设为那两张图片。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"自制Library并上传至Jcenter","date":"2016-07-31T15:32:51.000Z","path":"2016/07/31/自制Library并上传至Jcenter/","text":"1.首先在Bintray上面用github账号登录，会自动帮你建好9个仓库，我们要用的只有maven的repositories。进去后add new package添加一个包，要输入name、license、version等信息，最后为你建好的这个包的包名格式就是：账号名/maven/输入的name 。 2.进入自己已经写好的库工程。 3.进入项目的build.gradle，引入bintray的插件。即在dependencies中加入classpath ‘com.novoda:bintray-release:0.3.4’. (一个library的命名规则： GROUP_ID:ARTIFACT_ID:VERSION 分别是com.XX.XX、lib名、1.0.0) 4.进入module的build.gradle，配置bintray的信息。 申明bintray插件：apply plugin: ‘com.novoda.bintray-release’ 发布信息(与apply和android平级)： publish{ userOrg=&apos;开发者名&apos; groupId=&apos;库命名第一项&apos; artifactId=&apos;库命名第二项&apos; publishVersion=&apos;库命名第三项&apos; desc=&apos;描述语句&apos; website=&apos;描述网址&apos; } 最后sync now编译 5.terminal中上传 gradlew clean build bintrayUpload -PbintrayUser=用户名 -PbintrayKey=APIkey(网站的profile里面找) -PdryRun=false 6.进入网站，在该项目中点击add to Jcenter即可提交到Jcenter中供所有人调用。 我上传的库： 一、roundPic publish{ userOrg=&apos;livmortis&apos; groupId=&apos;com.roundPic&apos; artifactId=&apos;roundPic&apos; publishVersion=&apos;1.0.0&apos; desc=&apos;draw a round picture for display&apos; website=&apos;&apos; } 调用方法： compile ‘com.roundPic:roundPic:1.0.0’ 可用类：MyImageView，用于绘制一个圆形头像。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"Android热更新的实现","date":"2016-07-22T15:43:00.000Z","path":"2016/07/22/Android热更新的实现/","text":"发展逻辑 一个dex最多65536个方法。———-(1)插件化即独立功能做成独立apk，dexClassLoader动态加载反射调用插件中的类和方法（插件化只适合比较独立模块+必须使用框架）。——–(2)dex分包法，核心功能类放入第一个dex，其他放入第二个以及其余的dex中并以资源文件的形式打包入apk，多个dex文件都塞入classLoader中。———(3)QQ空间把修改过的类的class文件打包成patch.dex。 QQ空间hotfix框架。 相关框架：HotFix-Nuwa-RocooFix , DroidFix。 hotfix地址：https://github.com/dodola/HotFix.git CLASS_ISPREVERIFIED的问题。 1、在虚拟机启动的时候，当verify选项被打开的时候(doVerify变量为true)，如果static方法、private方法、构造函数等，其中的直接引用（第一层关系）到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志。那么，我们要做的就是，阻止该类打上CLASS_ISPREVERIFIED的标志。 2、举例：A类中的方法所引用到的B类和A类本身都在一个dex文件中，A就会被打上CLASS_ISPREVERIFIED标志。这是如果更新B补丁就会出错。 3、解决方案：AntilazyLoad类被打包成单独的hack.dex，让所有的类都在构造方法中引用AntilazyLoad类，就防止了类被打上CLASS_ISPREVERIFIED的标志了，只要没被打上这个标志的类都可以进行打补丁操作。注意hack.dex包要被优先加载。 4、解决方法：在dx工具执行之前，将LoadBugClass.class文件进行修改，再其构造中添加System.out.println(dodola.hackdex.AntilazyLoad.class)，然后继续打包的流程。注意：AntilazyLoad.class这个类是独立在hack.dex中。 5、解决过程： 1&gt;.javassist修改类的class文件。 String path = &quot;/Users/zhy/develop_work/eclipse_android/imooc/JavassistTest/&quot;; ClassPool classes = ClassPool.getDefault(); classes.appendClassPath(path + &quot;bin&quot;);//项目的bin目录即可 CtClass c = classes.get(&quot;dodola.hotfix.LoadBugClass&quot;); CtConstructor ctConstructor = c.getConstructors()[0]; ctConstructor .insertAfter(&quot;System.out.println(dodola.hackdex.AntilazyLoad.class);&quot;); c.writeFile(path + &quot;/output&quot;); （为什么不编译时就修改呢?答：源码方式的引用会将引用的类打入同一个dex中，所以我们需要找到一种既能编译通过并且将两个互相引用的类分离到不同的dex中，于是就有了这个动态的代码植入方式。） 2&gt;.在dx之前进行javassist操作。只需修改app/build.gradle 一、注意点 1.由于原理是在数组中补丁类放在bug之前，优先执行从而使bug类不在执行，那么只要轮到bug执行了补丁就不会再被执行。所以demo无法实现使使用者看到bug由错误到正确的过程。 2.CLASS_ISPREVERIFIED的问题出现在较多类存在而发生的处在同一Dex中的问题，demo主程序规模较小，暂不考虑这个问题。 3.补丁类必须和bug类包名+类名完全相同。 4.dex文件中可以有多个类，由于一个完整的类是由包名+类名组成，在将.java类文件转换为dex文件过程中，.java和.class文件是不包含包名信息的，输入时必须前面跟上包名，所以若要使jar包中有包结构，即包含包名信息，class打包时要连同包路径一起打。 二、编写程序。 1.新建一个准备被替换的类BugClass，它肯定不会被执行。 2.建一个与BugClass类包名+类名完全相同的补丁类，加入语句： public class BugClass { public String bug(){ return &quot;this is a bug&quot;; } } 将它进行如下转换.java–&gt;.class–&gt;.jar–&gt;dex包，变为BugClass_dex.jar放入src-main-assets文件夹下，等待主程序中调用。 3.新建一个类继承Application，它生命周期的onCreate()会优先于Activity的onCreate()，所以将引入补丁语句放到这里会保证它门能优先于Bug类执行，同理将CLASS_ISPREVERIFIED问题中的引入AntilazyLoad类语句放到这里，也是处于相同考虑，保证在类被贴上CLASS_ISPREVERIFIED标志前引用到AntilazyLoad类。加入语句如下： public void onCreate() { super.onCreate(); FileTrans mFileTrans= new FileTrans(); Fixbug mFixbug = new Fixbug(); File dexPath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE), &quot;BugClass_dex.jar&quot;); mFileTrans.prepareDex(this.getApplicationContext(), dexPath, &quot;BugClass_dex.jar&quot;); mFixbug.patch(this, dexPath.getAbsolutePath(), &quot;com.example.administrator.test.BugClass&quot;); } 新建一个File对象用来存放我们暂存在assets中的dex文件。File构造器参数为File类型路径和String类型文件名，这里getDir采用了MODE_PRIVATE模式，这个私有路径是在/data/data/包名/files下，没刷root的机子是无法看到/data分区的，dex放在这里能增强隐蔽性。将返回的补丁文件路径传入trans()方法进行dex转移。再将这个路径下转移来的dex文件传入patch()方法。 4.读取并转移dex，trans()方法如下： public boolean trans(Context context, File dexInternalStoragePath, String dex_file) { BufferedInputStream bis = null; OutputStream dexWriter = null; try { bis = new BufferedInputStream(context.getAssets().open(dex_file)); dexWriter = new BufferedOutputStream(new FileOutputStream(dexInternalStoragePath)); byte[] buf = new byte[BUF_SIZE]; int len; while ((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) { dexWriter.write(buf, 0, len); } dexWriter.close(); bis.close(); return true; } catch (IOException e) { if (dexWriter != null) { try { dexWriter.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } if (bis != null) { try { bis.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } return false; } } 代码利用简单的输入输出流将dex从assets转移到了app的/data私人目录下。 5.patch()方法如下： public void patch(Context context, String patchDexFile, String patchClassName) { if (patchDexFile != null &amp;&amp; new File(patchDexFile).exists()) { try { if (hasDexClassLoader()) { injectAboveEqualApiLevel14(context, patchDexFile, patchClassName); } } catch (Throwable th) { } } } private static boolean hasDexClassLoader() { try { Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;); return true; } catch (ClassNotFoundException e) { return false; } } 这里加入一个判断句确保可以得到系统的DexClassLoader，接下来调用injectAboveEqualApiLevel14()方法，将补丁类路径patchDexFile和补丁类名patchClassName传入。 6.下面到了最关键部分，injectAboveEqualApiLevel14()方法调用完便完成了补丁注入，具体内容如下： private static void injectAboveEqualApiLevel14(Context context, String str, String str2) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader(); Object a = combineArray(getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList( new DexClassLoader(str, context.getDir(&quot;dex&quot;, 0).getAbsolutePath(), str, context.getClassLoader() ) ) )); Object a2 = getPathList(pathClassLoader); setField(a2, a2.getClass(), &quot;dexElements&quot;, a); pathClassLoader.loadClass(str2); } 简单说，得到了两个类加载器，PathClassLoader和DexClassLoader，前者由系统context.getClassLoader()获得，负责加载主程序中的类，将它传入getPathList(pathClassLoader)方法即可获得PathList对象，通过pathList对象，即将它传入getElements(pathList)即可获得dexElements数组，dexElements数组的每个元素是一个dex文件，每个Dex文件中保存着多个类，类加载便是遍历数组找类对应的dexFile。 从后者DexClassLoader的构造方法可以看出它是用来加载我们那个补丁dex中的类的一款类加载器。之前DL框架中研究过它的构造方法，这里在复习一遍，四个参数： dexPath 需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 &quot;:&quot; optimizedDirectory 优化后的dex文件存放目录，不能为null libraryPath 目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null parent 该类装载器的父装载器，一般用当前执行类的装载器 我们这里的第一个参数正是上面传入的补丁BugClass_dex.jar的路径，所以创建对象时的构造方法即决定了一个DexClassLoader将要加载的是哪个类。然后是同样的方法的到补丁包的dexElements数组，我们这里只有一个元素BugClass.dex。 下一步利用combineArray()方法将两个数组合并，第二个放在第一个前面，得到新数组a。 旧pathList是a2，然后用setField(a2, a2.getClass(), “dexElements”, a)方法，这个方法就是反射得到“dexElements”成员变量，然后将第四个参数a即新数组放入了第一个参数a2即pathList中。方法的具体实现逻辑稍后再说。 补丁注入完成，简单来说这个方法的逻辑：PathClassLoader得到主程序的pathList中的dexElements数组，DexClassLoader得到我们补丁的pathList中DexClassLoader，两数组合并，新数组再放入pathList中，大功告成。 7.介绍上一步调用的getPathList()getDexElements() getField() setField()combineArray()appendArray()六个方法内部逻辑。 private static Object getPathList(Object obj) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { return getField(obj, Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;), &quot;pathList&quot;); } private static Object getDexElements(Object obj) throws NoSuchFieldException, IllegalAccessException { return getField(obj, obj.getClass(), &quot;dexElements&quot;); } private static Object getField(Object obj, Class cls, String str) throws NoSuchFieldException, IllegalAccessException { Field declaredField = cls.getDeclaredField(str); declaredField.setAccessible(true); return declaredField.get(obj); } getPathList()和getDexElements()，本质上都是利用getField()得到自己所需的成员变量PathList和Elements。在看getField()，这里集中体现了反射思想，第二个参数是class对象，利用它可以调用该Class的变量、方法、构造方法等。这里调用了第三个参数为名字的成员变量，设好访问权限，返回该成员变量。 放到getPathList()，即是用BaseDexClassLoader的class对象调用并返回它的pathList变量。放到getDexElements()中，就是调用并返回PathList类的dexElements变量 8. private static void setField(Object obj, Class cls, String str, Object obj2) throws NoSuchFieldException, IllegalAccessException { Field declaredField = cls.getDeclaredField(str); declaredField.setAccessible(true); declaredField.set(obj, obj2); } 类似getField()，但是得到成员变量后，将其值由第一个参数值变为第四个参数值。回顾上面引用该方法的injectAboveEqualApiLevel14()，里面即是用新pathList替换旧pathList。 9.数组合并方法 private static Object combineArray(Object obj, Object obj2) { Class componentType = obj2.getClass().getComponentType(); int length = Array.getLength(obj2); int length2 = Array.getLength(obj) + length; Object newInstance = Array.newInstance(componentType, length2); for (int i = 0; i &lt; length2; i++) { if (i &lt; length) { Array.set(newInstance, i, Array.get(obj2, i)); } else { Array.set(newInstance, i, Array.get(obj, i - length)); } } return newInstance; } private static Object appendArray(Object obj, Object obj2) { Class componentType = obj.getClass().getComponentType(); int length = Array.getLength(obj); Object newInstance = Array.newInstance(componentType, length + 1); Array.set(newInstance, 0, obj2); for (int i = 1; i &lt; length + 1; i++) { Array.set(newInstance, i, Array.get(obj, i - 1)); } return newInstance; } 前者是将一个数组放在另一个数组前，后者是将一个对象放入一个数组前，这里用了前者。逻辑很好理解，看下图即可，需要一步反射得到参数类型作为新数组的元素类型。 附： 补丁类变为dex: 1. java-&gt;class, cmd进入java源码目录下(不是类所在目录，而是包目录，即上升3到4个目录)， [javac -source 1.6 -target 1.6 包名\\abc.java] 2. class-&gt;jar, [jar cvf abc.jar 包名\\abc.class]； 3. jar-&gt;dex, 先要进入dx所在文件（dx工具要复制到sdk的platform-tools下）。将jar包拷过来。 [dx –dex –output abc_dex.jar abc.jar], *是abc.jar的绝对路径； 4. 完成。 反编译： 1.将dex反编译为jar 使用dex2jar工具，要将目标dex文件复制到dex2jar.bat所在目录dex2jar-0.0.9.15 文件夹。先进入该文件夹。 [dex2jar.bat dex文件名] 2.读取jar文件 jd-gui工具。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"android studio下动态加载DL框架的使用","date":"2016-07-19T13:43:40.000Z","path":"2016/07/19/动态加载DL框架的使用/","text":"一、DL和插件化的意义 动态加载技术即dynamic-load-apk，简称DL。当公司项目越来越大时，第一应用的内存和CPU占用压力大幅度增大，第二添加新功能必须发布新补丁，频繁升级安装新版本。”插件化”的思想即是将应用拆分为许多插件，每个插件对应特有的功能，再加上”动态加载”技术，使插件不需要安装即可被调用。安装卸载整个应用从而变成了单个插件的热插拔。 二、动态加载的思想。 一个宿主程序（host），可以任意调用各个尚未安装的插件APK。 三、动态加载的模式 根据插件和宿主依赖与否分为三种，这里使用插件不依赖宿主的模式，即两者独立开发，各自依赖DL的jar包。 四、功能实现。1.开源框架地址 https://github.com/livmortis/dynamic-load-apk.git 项目根目录下的脚本是无法运行的，需要打开对应子项目。其中有lib和sample两个文件，sample是一个演示demo，lib即是我们开发自己项目时需要的库文件。 2.导入框架 由于插件程序和宿主程序都需要DL的jar包即lib.jar，但是在宿主程序直接依赖的情况下，插件程序不能直接依赖，否则宿主调用插件时会出现类重复错误，support-v4同理。解决方法是插件项目中新建一个文件夹，将lib.jar和support-v4.jar放进去并进行依赖，这样即在编译时用到了库而又不会将库打包到APK中。 项目的jar包在eclipse中会自动生成在lib文件夹中，而在AS中可以在build.gradle中用”task makeJar”语句生成。不过我们可以偷个懒，因为自带的demo中也有插件程序，在它自建的文件夹中可以找到直接拷。（lib-build-libs中也可找到lib.jar） 3.插件程序开发 这里只演示一个简单的textview. public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvS = (TextView) findViewById(R.id.tv_success); } 插件中Activity必须继承自DLBasePluginActivity，相应的调用activity要用startPluginActivity(intent)。另外注意删掉styles.xml中的一些没用到的变量，否则打包时会出错。另外manifest.xml中活动的theme要分别设置。 然后打包APK，放入手机存储或SD卡的指定路径。 4.宿主程序开发String dexPath = Environment.getExternalStorageDirectory() + &quot;/AAAdltest&quot;; File file = new File(dexPath); File[] plugins = file.listFiles(); 首先逐个读取APK所在路径下的文件，可以挨个读取该路径下的APK。 public static class PluginItem { public PackageInfo packageInfo; public String pluginPath; public String launcherActivityName; public PluginItem() { } } 将packageInfo,插件路径，插件程序活动名放入自定义内部类PluginItem中。 for (File plugin : plugins) { item = new PluginItem(); item.pluginPath = plugin.getAbsolutePath(); item.packageInfo = DLUtils.getPackageInfo(this, item.pluginPath); 这里packageInfo用到了框架类DLUtils中的getPackageInfo()方法，点开该类可以看到这个方法： public static PackageInfo getPackageInfo(Context context, String apkFilepath) { PackageManager pm = context.getPackageManager(); PackageInfo pkgInfo = null; try { pkgInfo = pm.getPackageArchiveInfo(apkFilepath, 5); } catch (Exception var5) { var5.printStackTrace(); } return pkgInfo; } 方法返回值packageInfo，其实是通过PackageManager的getPackageArchiveInfo()方法得到的，该方法第一个参数要传入是想要得到包信息的apk的路径。 有了packageInfo就可以得到插件程序中activity的数量，利用name属性将第一个activity也就是MainAcitivity名取出： if (item.packageInfo.activities != null &amp;&amp; item.packageInfo.activities.length &gt; 0) { item.launcherActivityName = item.packageInfo.activities[0].name; } DLPluginManager.getInstance(this).loadApk(item.pluginPath); } 最后调用DLPluginManager的startPluginActivity（）来启动插件程序的MainActivity。 DLPluginManager pluginManager = DLPluginManager.getInstance(this); pluginManager.startPluginActivity(this, new DLIntent(item.packageInfo.packageName, item.launcherActivityName)); 5.宿主程序manifest.xml 添加代理Activity声明。这里如果不添加会报ActivityNotFoundException错误，而插件程序的库文件中虽然也有该活动，但程序没有调用到相关类，所以不声明也不会出错。 &lt;activity android:name=&quot;com.ryg.dynamicload.DLProxyActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.ryg.dynamicload.proxy.activity.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 加入读写SD卡权限 &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; 6.运行结果 宿主程序成功打开了未安装的插件程序apk。 7.生命周期的思考 插件中的Activity在宿主程序调用后只是普通的Class，其生命周期也无从谈起，解决方法就是将宿主程序的生命周期与其绑定，看看源码中是怎么办到的。 反射加载插件程序中成员的逻辑是写在代理活动中的，所以宿主程序主要运行在DLProxyActivity生命周期中的。 打开代理类DLProxyActivity： protected DLPlugin mRemoteActivity; protected void onStart() { this.mRemoteActivity.onStart(); super.onStart(); } protected void onRestart() { this.mRemoteActivity.onRestart(); super.onRestart(); } .... DLPlugin是一个接口，里面封装了生命周期相关所有方法。刚才写插件程序时提到了所有活动要继承DLBasePluginActivity，打开DLBasePluginActivity，发现它果然实现了DLPlugin接口，这也验证了我们的猜想。 8.类加载机理 上面宿主程序中用到了DLPluginManager的loadApk()方法，该方法内部主要调用了preparePluginEnv()方法，其中有如下语句： DexClassLoader dexClassLoader = createDexClassLoader(dexPath); 打开createDexClassLoader()： 返回值为 DexClassLoader loader = new DexClassLoader(dexPath, dexOutputPath, mNativeLibDir, mContext.getClassLoader()); 可见，android类加载器DexClassLoader构造器需要传入apk地址、dex文件存放地址、java类加载器ClassLoader()等参数。有了类加载器，我们就可以利用反射来调用插件中的各种对象了。 打开DLProxyImpl这个类，其中一个方法有如下内容： Class&lt;?&gt; localClass = getClassLoader()（这里传入的类加载器正是上面我们得到的）.loadClass(mClass); Constructor&lt;?&gt; localConstructor = localClass.getConstructor(new Class[] {}); Object instance = localConstructor.newInstance(new Object[] {}); 这里的mClass是我们传入的插件中想要加载的类，利用反射原理，通过类加载器得到mClass的class对象，即可得到构造函数，从而得到mClass的实例对象instance。利用class对象也可以得到mClass的包括onCreate(）在内的各种方法，然后使用invoke()调用这些方法，最终完成插件程序的加载。 五.下一步工作 开始研究Android热更新，将动态加载应用到项目中。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"五个角度分析android性能优化问题","date":"2016-04-17T16:35:03.000Z","path":"2016/04/18/五个角度分析android性能优化问题/","text":"UI优化一、丢帧和卡顿1.现象 帧率fps：一秒钟内的帧数，即一秒钟GPU执行绘制的次数。 显示频率HZ：一秒钟更新显示的次数。 若60HZ（一般手机配置）搭配小于60fps的帧率，出现丢帧。 所以标准一次绘制的时间1000ms/60=16ms。时间长于16ms的绘制会出现丢帧，或者画面上下断裂等现象。 1.原因及解决 1&gt;布局太深。采用布局扁平化设计，防止多层嵌套，可通过适当将LinearLayout改为RelativeLayout等方式降低布局的层数（其余情况线性布局由于其onDraw()方法调用次数相对少，因而比相对布局有更高的效率）。 2&gt;布局太多。 标签来重用layout代码，以及删减多余或者额外的层级。 3&gt;UI绘制单元太多，CPU/GPU负载过重。减少不必要的绘制单元或控件。 4&gt;动画次数过多，16ms内无法完成。 2.工具 开发者选项中的每帧占用时间，用条状显示在界面上。16ms为界限，蓝色表示measure和draw所用时间，红色表示渲染时间，黄色表示CPU等待GPU运行时间。（支付宝的”口碑外卖””蚂蚁聚宝””游戏中心”三个活动转场时有短暂的较长的紫色线条，知乎转场时黄红线条，两者Listview滑动时都表现出色小于16ms） 二、OverDraw1.现象 对不可见的UI进行了绘制或者更新，浪费资源，导致卡顿。 观测工具：开发者选项中的GPU过度渲染显示，控件重叠从低到高依次显示蓝，绿，粉，红色。 2.解决（以background为例） 1&gt;将Window的默认background移除。 2&gt;移除不必要的background。 3&gt;设置ImageView的transparent属性，使没有获取到图片时才调用background。 三、自定义view的问题 自定义view的三大流程measure，draw和layout中measure和layout最耗时。 而且如果是自定义View碰到overDraw的情况，系统无法检测onDraw()中的操作而完成自动优化，canvas的clipRect()和quickReject()使创造一个只能在里面进行绘制的矩形区域，避免的过度渲染问题。 内存优化一、频繁gc1现象。 回收所有不可达对象的gc机制执行时，其他线程任务会暂时停滞。因此过长和过于频繁的gc降低效率会导致卡顿。 2.解决 1&gt;避免过于频繁的new对象和gc回收对象，比如避免for循环中出现创建对象语句。 2&gt;避免在onDraw()语句中创建对象。 3&gt;优化listview。构建adapter是使用contentView缓存，减少创建View对象次数。 4&gt;适用对象池模型。 5&gt;gc对数组、队列、数、图的回收效率低，尽早将不用的设为null。 3.优化后的JVMgc机制。 三级generation：young generation,old generation,permanent generation。不可达的对象依次进入每级内存区域，第一个区域进行快速创建和回收，同样对应最短的gc时间，后两个依次增加。 二、leak原因及解决 1.数据库的cursor没有及时关闭。及时调用close()对其关闭。 2.线程没有及时终止，会持续占据内存。及时调用remove()清除。 3.Bitmap对象不使用时采用recycle()释放内存。 三、阻塞 1.子线程。耗时任务如果在主线程执行，会导致UI线程阻塞，将耗时语句如下载文件、读写数据库等放到子线程执行。 2.线程池。线程不可能做到绝对的并行，只会通过时间片轮转的方式调度每个线程。因此需要一个线程池存放线程的缓存，否则大量线程的创建和销毁会消耗大量时间，入不敷出 四、溢出 多数OOM都是因为Bitmap太大。 1.大图采用压缩图片。通过设置BitmapFactory.Options中inSampleSize的值对图片进行压缩。 2.多图采用缓存图片。使用LruCache（是一个LinkedHashMap ），从cache中去取出Bitmap显示，如果缓存中不存在就启动一个task去加载（from文件或网络） 五、内存工具 1.Heap Tool 进行内存快照，如需检测某个对象是否被回收，在System.gc()前后各拍一张内存快照进行对比。另外当heap size超过阈值时自动OOM。 2.Allocation Tracker 从开始到结束之间时间段监测内存调用情况，查出leak元凶。 3.Memory Monitor 查看APP整体消耗内存情况，以及发生GC的时刻。反映出当前操作带来的CPU和内存变化。 4.traceView。 运算优化 1.float比int计算慢几倍以上。 2.算法上进行优化。如使用排序中的快排归并堆排，查找使用二叉树和平衡树等。尽量不用O(n*n)时间复杂度以上的算法，必要时候可用空间换时间。 3.数据类型的选择。如hashmap,hashset的选择，StringBuilder代替String，ArrayList和LinkedList的选择 4.采用JNI，将耗时间的处理放到c/c++层来处理。 5.尽量采用文件操作，其速度比数据库的操作要快10倍左右。 6.如果方法用不到成员变量，可以把方法申明为static，性能会提高到15%到20%。static的变量如果不需要修改，应该使用static final修饰符定义为常量。 7.使用单例模式。 8.提前或延迟操作，错开时间段提高TPS。Android中除了支持ScheduledExecutorService之外，还有一些delay操作，如handler.postDelayed，handler.postAtTime，handler.sendMessageDelayed，View.postDelayed，AlarmManager定时等。 网络优化 1.对于现成的HTTP框架，有很多需要服务端配合的，比如：json数据格式代替xml或html，WebP代替jpg，支持断点续传，多个请求合并成一个，尽量不做重定向，服务器缓存以及负载均衡等。 2.对客户端本身，除了上述的实现，我们还需要合理的缓存，控制最大请求并发量，及时取消已失效的请求，过滤重复请求，timeout时间设置，请求优先级设置等。 电量优化 1.PowerManager.WakeLock可唤醒手机，调用完后记得恢复原始状态。 2.不同电量执行不同策略。获取手机充电状态信息，将耗电任务放到充电时进行等。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"Broadcast_Receiver总结","date":"2016-04-14T15:13:54.000Z","path":"2016/04/14/Broadcast-Receiver总结/","text":"广播的基础知识点不多，但最近都没怎么用到回头看看发现有些生疏，现总结一下方便以后快速回忆。 一、发送广播：1. 标准广播 （Normal broadcasts）-异步执行： Intent+sendBroadcast()。 Intent可以显式或隐式，显式即两个参数类和接收器，隐式一个参数为该广播的action。一般选择隐式发送。 2. 有序广播 (Orderd broadcasts)-同步执行： Intent+sendOrderedBroadcast()。 sendOrderedBroadcast()会有两个参数第二个为null。 接收器可以在标签中添加priority优先级。（标准广播也可以设置优先级） 接收器可以在onReceive()方法中使用abortBroadcast()截断广播。 二、接收广播： 注册广播+创建广播接收器子类 1.注册广播：是”广播接收器”(主语)注册自己想要接收的”广播”(宾语)。 1&gt; 动态注册（通过IntentFilter类）（必须程序启动后才能接受广播） 1、先判断接收器为null即尚未创建对象，然后建广播接收器（系统的或自定义的）的子类的对象。 2、建IntentFilter对象，构造函数为目标广播action，或者对象调用addAction()来传入目标广播action。（通过action来选择监听什么广播） 3、调用registerReceiver()方法，参数一为接收器子类的对象，参数二为IntentFilter对象。（参数1为”主语”接收器，参数2为”宾语”广播） 2&gt; 静态注册（通过intent-filter标签） 1、manifest中建立标签，name写BroadcastReceiver子类名。 2、其中再建立标签，name可以写priority。 3、其中再建立标签，name写目标广播action。 4、若是接受系统广播，可能还要在中添加权限。 2.注销广播 活动的onDestroy()方法中，先判断接收器不为Null，调用unregisterReceiver()，参数之一为receiver子类对象。接收器设为null。 3.创建广播接收器子类。 new—other—BroadcastReceiver。或者自建class继承BroadcastReceiver，并在manifest中声明。 三、回应广播 重写BroadcastReceiver的子类中的onReceive()方法。 四、本地广播比起全局广播仅有以下两个区别：1、发送广播：sendBroadcast()方法要用LocalBroadcastManager类的对象来调用，其创建对象通过getInstance()方法。2、注册广播：registerReceiver()方法和unregisterReceiver()方法也要用LocalBroadcastManager类的对象来调用。3、本地广播不能用隐式注册，本地广播不怕机密数据泄漏、不怕恶意数据安全漏洞、更高效。 五、intent的action。 1.自定义的action的命名一般是包名+.+大写。 2.系统的action举例。 1&gt;网络变化：android.net.conn.CONNECTIVITY_CHANGE。 1.对应的类为ConnectivityManager，创建方式getSystemService(Context.CONNECTIVITY_SERVICE) 2.该类拥有的方法是getActiveNetworkInfo()，获取当前网络状况。 3.当前网络状况类NetworkInfo，拥有方法isAvailable()是否网络畅通，返回boolean值。 4.对应权限：ACCESS_NETWORK_STATE 2&gt;开机：android.intent.action.BOOT_COMPLETED。对应权限：RECEIVE_BOOT_COMPLETED。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"AIDL的简单使用","date":"2016-04-12T16:05:52.000Z","path":"2016/04/13/AIDL的简单使用/","text":"本文目标：进程间服务通信（多个进程共用一个服务）AIDL:android interface definition languageandroid5.0后启动服务只能用显式intent不能用隐式。 一、程序B启动程序A中的服务。 1.创立ComponentName对象，构造器参数一为包名，参数二为被启动的service包名+类名。 2.创立Intent对象，调用setComponent()，参数为ComponentName对象。 3.startService()。 注意：建立Service最好通过软件直接自动新建一个Service类。如果是手动建的类手动继承Service，需要在manifest下声明service并且加入以下权限： android:exported=”true” android:enabled=”true”否则会报java.lang.SecurityException: Not allowed to start service Intent { cmp=com.baidu.myapplication/.Myservice } without permission android.permission.BIND_REMOTEVIEWS错误。 二、程序B与程序A中的服务通信。 1.A程序中Service同等级创建AIDI接口文件。然后Build—rebuild project或者make project。进入AIDI，建立抽象方法setAbc()（自定义）。 2.Service的onBinder()中返回一个”AIDL子类对象.Stub()“（这说明AIDL实际上是一个Binder类型），并重写接口原有方法basicTypes()和自建方法setAbc()。 3.在service中建立String全局变量abc，使setAbc()成为它的setter方法。（先有setter()后有变量）此时即可通过操作AIDL来向服务传递信息。 4.B程序中创建Folder–AIDLfolder，里面新建与A程序包名相同的包，A程序中的AIDL文件拷贝到B程序中这个包里。rebuild或make。 5.B程序中建立bindService()，将ServiceConnection接口的onServiceConnected()方法的第二个Binder类型的参数”service”，赋给一个自定义的AIDL类型变量b。这个赋值过程注意，不能直接将service强制类型转换成AIDL类型，因为这时转换成的是A包路径下的AIDL，必须用以下方式：b=AIDL接口名.Stub.asInterface(“参数service”)。 6.b调用setAbc()向服务传递信息。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"service的温故知新","date":"2016-04-12T15:17:44.000Z","path":"2016/04/12/service的温故知新/","text":"一、Service的基本创建步骤活动中 1.启动服务，关闭服务，绑定服务，解绑服务：startservice(),stopservice(), bindservice(), unbindservice()。前两个参数参照startactivity()。都是由Activity调用的。 2.bindservice的参数(intent,ServiceConnection接口、（用来侦听服务的状态）的对象，Context.BIND_AUTO_CREATE), unbindservice(ServiceConnection的对象)。 3.实现ServiceConnection接口的两个方法：onserviceconnected()服务绑定后执行 onservicedisconnected()服务被杀掉时执行。 4.bindservice()—-同时执行了oncreate()和onserviceconnected(), unbindservice()—同时执行了onservicedisconnected()和ondestroy()。startservice()—-执行oncreate()和onStartCommand() stopservice()—执行ondestroy()。 服务中 1.继承Service后重写四个方法。onBind(), onCreate(), onDestroy(), onStartCommand()。 2.如需与活动建立连接，再自定义一个Callback接口和一个继承Binder的类。 二、Service的生命周期： 1.onCreate()和onDestroy()。 2.activity和service绑定时，退出活动服务也自动停止，没绑定则不停。 3.oncreate()和onstartcommand()的区别，每次startservice时就会onstartcommand（）一次，而oncreate()只在第一次startservice时执行，之后一直存在。 4.若startService()和bindService()都执行了，再想销毁服务，必须stopService()和unBindService()都执行。 三、Activity与Service传递信息。1、活传服方法一利用onstartcommand()。 activity要给service传递数据，Intent搞好后只需利用onstartcommand()参数中的intent接受即可 2、活传服方法二利用onbind()。 （更方便更快，不需要Intent）（要传递的信息变量放在自定义类A中）（必须绑定后才能传递数据，方法一开始即可传递） 核心思想：传递数据即想办法给对方的成员变量str赋值。 关键环节：onbind()方法的返回值会传递到活动中的onServiceConnected()的参数中。 1&gt; Myservice中建内部类A，继承Binder。 2&gt; A中str是服务要printf的数据，为其建立setter方法。（str并不是在A中定义的） 3&gt; 让onbind()的返回值为A的对象 4&gt;这个对象会被传递到Activity中的onserviceconnected()中的第二个参数”service”。（别问为什么） 5&gt;在活动中新建一个A类型（Myservice.A）的变量a，把service赋给a，a调用setStr()即可给Service服务类中的str赋值。 3、侦听服务中数据（监听服务中的变化例如++） –回调机制。将服务中的信息显示在活动UI中。 核心思想：上面是把str数据封装到set方法里，这里是把”接口的对象”封装到set方法里，而str数据藏在接口中的抽象方法里。 1&gt; 服务中新建一个接口Cb，定义一个抽象方法onchange(str)。通过这个方法传递服务到活动的数据。 2&gt; 建一个private类型的Cb成员变量cb，配上set和get方法来封装好(别人通过这俩方法调用它”NO!没人想调用cb”)。set方法是为了利用它的参数即接口的变量/对象cb。 3&gt; 在服务的oncreate()中（很可能是子线程中），将服务自己内部的可能是不停变换的那个数据，放入cb所调用的onchange(str)方法的参数里（自己当场建onchange()方法），传给了接口CB。【服务子线程onchange()传到了服务主线程onchange()】 4&gt; 内部类A中新建getsss()方法，返回MyServvv.this。(返回值是MyServvv)（因为A类的对象可以传递到活动中 见上回） 5&gt; 活动中，将onServiceConnected()的第二个IBinder类型参数赋给自己建的A类型的变量a（强制类型转换为MyServvv.A），a调用getservice()再调用set方法（而不是get方法），其参数就是接口的对象，用匿名类变成new Cb，重写方法onchange(str)，数据str传出。 4、支线数据传到主线。 1&gt;匿名类方式创建一个Handle对象，重写Handle接口的方法handleMessage(Message msg)。 2&gt;支线中创建Message对象msg,调用setData，参数必须是Bundle过后的数据。 3&gt;handle对象调用setmessage（），参数是msg。就将数据传递到了匿名类的handlemessage中。 4&gt;匿名类中msg调用getdata()，再getstring()即可。 四、一些细节： 1.java.util.logging.Handler包的Handler是错的。必须是android.os.Handler;。 2.message传递的是bundle包好的数据，handleMessage()中要对数据调用getData()+getString(key)两个方法才能提取出来。 3.如果不在onDestroy()设置结束服务，就会报android.app.ServiceConnectionLeaked错误。 4.如果服务子线程内部调用CallBack接口方法时没有if (callback != null) 条件句，会爆java.lang.NullPointerException: Attempt to invoke interface method &#39;void com.baidu.myapplication.MySer$Callback.onChange(java.lang.String)on a null object reference错误。因为此时callback变量还是null，我写的接口定义的语句还在下面没被执行到。 5.重要！Handler不能在子线程中创建对象，需在直接用外部UI线程创建好的Handler对象，否则报 Can&#39;t create handler inside thread that has not called Looper.prepare()错误。 6.开始、绑定、解绑、结束等方法里的intent对象必须共用，即提前初始化好Intent对象，才是指向同一个service的。 7.editText调用getText()同时必须toString()！ 8.当通过onBinder()+Binder子类的方式，从活动传递信息给服务时，服务中接受并在子线程中展示的那个数据，必须在服务类下定义为全局变量，而Binder子类的作用仅仅是为该变量提供一个setter()方法供活动去修改。绝不可以把变量定义到Binder子类中作为局部变量再提供个getter()方法，而子线程中再new Binder子类，再通过getter()得到变量，这样接收到的数据是null，原因不明。 五、那么Service和子线程该怎么选择呢 1.程序的进程关了service还在运行，子线程不行。 2.长时间在后台运行，用service。 3.默认情况下，Service其实是运行在主线程中的，如果任务占用CPU时间多，资源大的情况下，要使用线程。 4.可以在任何有 Context 的地方调用Context.startService、 Context.stopService、 Context.bindService， Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 5.Service的优先级高于后台挂起的Activity和Activity所创建的Thread，不易被杀。 6.其实应该考虑的问题是子线程应该在Activity开，还是Application中开，还是Service中开。前两者Thread的生命周期都不应该超出整个应用程序的生命周期，只有在Service里开线程可以在Activity结束后跟随service继续运行。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"android手机UI适配相关","date":"2016-04-10T15:56:10.000Z","path":"2016/04/10/手机UI适配相关/","text":"手机屏幕尺寸：S5:5.1英寸 iPhone5s 4英寸；iPhone6 4.7英寸； iPhone6Plus 5.5英寸；mate7 6英寸 small——小于3英寸 ； normal——小于4.5英寸； large——小于7英寸； extra large——小于10英寸 分辨率：px*px(像素乘像素) WVGA:800*480(三星G9198) DVGA:960*640(果4) HD720：1280*720(红米，S3)（占有率第一） HD1080：1920*1080(MATE7，S5)（占有率第二） WQHD（2K屏）:2560*1440(find7,S6,S7) 逻辑分辨率：dp为单位。320dp和360dp两种（指逻辑宽度）。 像素密度：S5:432ppi 120dpi(Ldpi) 160dpi(Mdpi) 240dpi(Hdpi) 320dpi(XHdpi) （占有率第一） 480dpi(XXHdpi)（占有率第二） 640dpi(XXXHdpi)(S7)。 其中Mdpi的1px=1dp。XXHdpi的1dp=3px。XXXHdpi1dp=4px。 因为dp=(160/ppi)*px","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"surfaceView入门","date":"2016-04-07T15:52:40.000Z","path":"2016/04/07/surfaceView入门/","text":"使用过程： 1.主动更新时需要一个线程去操作，此时选择surfaceView而不选View。 2.新建类继承SurefaceView类，实现SurfaceHolder.CallBack接口。 3.实现一个构造器和三个方法：surfaceChanged() surfaceCreated() surfaceDestroyed()，参数都包含SurfaceHolder对象。 4.构造器中创建一个回调函数，getHolder().addCallBack(this)。初始化paint画笔。 5.自定义一个draw()方法，创建Canvas画布,并在开头和结尾添加锁定（getHolder().lockCanvas()）和解锁画布(getHolder().unlockCanvasAndPost(canvas))两条语句。中间用画布Canvas绘制之。 6.在surfaceCreated()（Or surfaceChanged()）中调用自定义方法draw()。 细节： 1.canvas的drawColor()改变的是画布背景，要放在绘制语句前面，否则背景会掩盖绘制的图像。paint的setColor()改变的是画笔的颜色。 2.canvas的save()和restore()方法成对出现，效果是让它俩之间的操作如rotate()（旋转画布）不影响restore()之后的操作。 3.SurfaceView有生命周期，若有线程要把关闭线程语句放在surfaceDestroy()里。 利用容器绘制组合图形 思想：父容器类中有一个存放容器的集合，每个容器都是一个子view，并且都有一个继承了父容器类的类。所以每个子view也有自己的集合也可以添加其他子view（图形组合拼接）。 1。新建一个容器类Container。 构造器中创建容器类泛型List集合，集合元素是容器（其实是子view）（每个子view是一个图形）。 新建两个方法。一个是draw()方法，另一个是childrenView()。在draw()中首先调用childrenView()(因为真正的绘制代码在这里)，然后foreach遍历集合中的子view（每个元素都是一个图形），再递归的调用自己即“container的draw()”。逻辑梳理：若集合中有了多个子view，那么子view肯定已经有了childrenView()这个绘制图形的能力，那就让这些子view依次调用childrenView()即可绘制。通过一个draw()的递归行为来实现这一目的。 新建两个向集合中添加和删除容器的方法。 2。新建一个代表具体图形的子view继承Container容器类。 构造器中初始化paint画笔。 重写父类的childrenView()，绘制图像（真正的图形的绘制代码在这里）。 3。新建一个类继承surfaceView实现Callback。 构造器中首先创建好Container和图形类的对象。别忘addCallBack()。 其次建立一个自定义方法drawuck()，内部先用锁画布+解锁画布包裹后再开始写代码。让多个图形拼接，即一个调用”添加集合方法”添加另一个，直到把母图形添加到container中。最后重写Container的draw()进行绘制。 绘制行为的调用关系：surfaceView调用Container的draw()，draw()递归的调用自己让集合每个元素调用childrenView()，子view类重写childrenView()添加真正的绘制行为。 利用容器使组合图形移动 1.容器类 1&gt;容器类中建立坐标变量x,y，并为之添加get()set()方法。 2&gt;在容器类draw()方法中书写移动逻辑。调用canvas自带的瞬移方法translate()，两个参数为两个坐标的get()方法。将之用save()restore()包裹。 2.Rect类（用例类） 在Rect类中的childrenView()方法里，获取translate()的两个参数将其递增——get()作为set()的参数… 3.surfaceView子类 1&gt;surfaceView子类中建立两个方法——startTimer()，stopTimer()。 2&gt;在startTimer()中创建两个对象——Timer对象，TimerTask对象。 首先用schedule()方法启动Timer，参数为TimerTask对象和间隔时间。 然后在TimierTask接口匿名类中的run()里面写入drawuck()（surfaceView中自定义的绘制方法）。 3&gt;stopTimer()中确定timer不为空后cancel()，然后赋予null。 4&gt;分别将startTimer()和stopTimer()放入surfaceCreate()和surfaceDestroyed()。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"自己制作美美的View界面","date":"2016-04-05T12:52:24.000Z","path":"2016/04/05/自己制作美美的View界面/","text":"自定义view是android进阶之路上的必修课，能随心所欲做出自己设计的漂亮界面想想都小激动，终于等到发挥我设计天赋的时刻了，当然第一步还是得踏踏实实先把基本知识弄透彻。 一、View的继承关系类 ViewRoot是连接WindowManager和DecorView的纽带。 Activity创建–DecorView添加到Window–创建ViewRootImpl对象–关联DecorView和ViewRootImpl。 DecorView是顶级View，默认内部包括一个竖直的LinearLayout，里面是Title和Content。 二、三大流程之Measure流程1.MeasureSpec相关 MeasureSpec（由父容器的MeasureSpec的mode和LayoutParams共同决定）决定了一个普通View的尺寸大小；MeasureSpec（由窗口大小和LayoutParams共同决定）也决定了一个DecorView的尺寸大小。 普通View的模式和尺寸大小的决定规律： 它是一个32位int值，前两位是SpecMode，后三十位是SpecSize。其中SpecMode分成三类：EXACTLY（具体数值、match_parent）, AT_MOST（wrap_content）, UNSPECIFIED。 2.View的Mesure流程（Measure方法测量自己即可） 用到的方法：measure(), onMeasure() ,setMeasuredDimension() ,wantWidth(), wantHeight()(这两个是自定义) ，getSuggestedMinimumWidth() ,getSuggestedMinimumHeight(), getMode(), getSize() 1&gt;、View的measure()，是final所以不能改写，于是改写它所调用的onMeasure()方法。 2&gt;、setMeasuredDimention()方法是onMeasure()方法中的最主要方法，两个参数分别是宽和高，通过调用自定义的getWidth和getHeight来得到。 3&gt;、自定义的wantWidth()方法，有两个参数，第一个已经是size了，已经可以用来做返回值了（这样该方法就没意义了），是因为第二个参数是mesureSpec,用它来计算specSize，方法的目的正是考察specSize有没有必要代替掉size。考察依据：UNSPECIFIED模式则直接用size，EXACTLY模式和AT_MOST模式则用提取的specSize。 第一个参数size的来源：wantWidth()调用者调用了getSuggestedMinimumWidth()方法计算而出的。计算方法是直接返回android:minWidth这个属性值，若没有该属性值，就返回0（无背景）或是背景大小（有背景）。 第二个参数mesureSpec计算specSize的做法：通过MeasureSpec的getSize()方法，方法参数正是mesureSpec。同时通过MeasureSpec的getMode()方法得到specMode用来后面筛选。 4&gt;、如果通过继承View的方式自定义控件，wrap_content参数效果会和match_parent一样。所以必须重写onMeasure()。 3.ViewGroup的Mesure流程（Measure方法测量自己，和遍历的用Measure方法测量子元素） 测量子类时用的：measureChildren(),measureChild(),getLayoutParams(),getChildrenMeasuredSpec(),measure() ViewGroup是抽象类，所以测量自己的任务交给子类LineaLayout等去实现：onMeasure() 1&gt;、在measureChildren()中遍历对子view执行measureChild()方法。 2&gt;、在measureChild()方法中，先提取child的LayoutParams参数getLayoutParams()，然后将params作为三个参数之一传给getChildMeasureSpec()方法得到measureSpec，最后调用measure()方法传入两个measureSpec作为参数进行测量。 4.监听view的改变，调用view的尺寸信息。 1&gt;、onWindowFocusChange()方法，参数为boolean类型的hasFocus。内部判断hanFocus为真即可getMeasuredWidth()和getMeasuredHeight()。 2&gt;、view.post()方法。用它建立的线程中可直接getMeasuredWidth()和getMeasuredHeight()。 3&gt;、addOnGlobalLayoutListener()监听器方法。用法同事件监听器。调用者为view树ViewTreeObserver的对象，创建对象方法为getViewTreeObserver()。 4&gt;、view.measure()方法。 三、三大流程之Layout流程1、相关过程 layout作用是ViewGroup用来确定子元素的位置 layout()确定view本身的位置，onLayout()确定所有子元素的位置。 确定全部元素位置的层层递进过程：layout()（父元素自己定位）——onLayout()——setChildFrame()——layout()（子元素定位）——继续传递完成整个View树。 2、获取尺寸的位置 应该在layout中get尺寸，因为onMeasure()中得到的是“测量宽/高”，layout过程中得到的是“最终宽/高”。下面两种情况会导致不同： 1&gt;、重写layout()，将其四个参数（四个顶点坐标）改动 2&gt;、View需要多次measure才能确定“测量宽/高”，前几次测量会有出入。 四、三大流程之Draw流程1、View的绘制过程 1&gt;、绘制背景： drawBackground(canvas) 2&gt;、绘制自己： onDraw(canvas) 3&gt;、绘制children： dispatchDraw(canvas) 4&gt;、绘制装饰： onDrawScrollBar(canvas) 五、自定义View1、继承View。 1&gt;、新建类继承View，实现两个构造方法，两个参数的构造方法给布局用，一个参数的给活动用。 2&gt;、重写onDraw()，用它的参数canvas进行drawXXXX()绘制各种图形，新建Paint对象调用setColor(),setTextSize(),setARGB(),measureText()等方法进行修改。 3&gt;、重写onMeasure(),若想可以使用wrapContent属性则需重写此方法。若有必要还要加入padding修正代码。 4&gt;、动态效果。添加线程，线程中对坐标变量或颜色等属性进行循环变化（可充分利用Random对象的nextXXX()方法生产随机数），用包裹好的sleep()方法实现动态可见。线程中逻辑代码结束后调用postInvalidate()方法该方法会自动调用一次onDraw()。最后在onDraw()中创建该线程的对象，开启线程。 2、继承ViewGroup。3、继承特定的View。4、继承特定的ViewGroup。5、添加样式属性。 定义。 xml中定义样式：比如要想设为属性的值是A，在res-values文件中新建一个xml文件，添加标签，里面先设置name（自定义view类名），里面再添加标签，里面设置name（样式属性名）和format（样式属性类型如reference,dimension,color和基本数据类型等）两个值。 布局。 layout中添加样式属性：首先引入命名空间。xmlns:iOS=”http://schemas.android.com/apk/res-auto&quot;。然后即可在下面标签中设置属性。iOS:name名=&quot;值“ 解析。 最后进入自定义view类中的两个参数的构造方法进行解析。用context的obtainStyledAttributes()方法创建一个TypedArray对象。方法的两个参数分别是attrs和R.styleable.自定义view名。接着用该对象调用getInt()方法返回值赋给样式属性变量，两个参数分别是“R.styleable.自定义view名_样式属性名”和样式属性默认值。最后释放TypedArray,调用recycle()方法即可。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"关于android中的多线程和线程池","date":"2016-04-03T10:01:50.000Z","path":"2016/04/03/关于android中的多线程和线程池/","text":"首先get两个帮助测试时可以清晰了解线程动向的方法：Thread.currrentThread.getName() 显示当前线程。Thread.isAlive() 判断线程生命周期，只有新建和死亡两个阶段返回false。Runtime.getRuntime().availableProcessors() 显示CPU个数，可以依据这个创建线程个数。 接着区分几个概念： 并发与并行：多条指令在多个处理器上同一时刻执行为并行，多条指令在快速轮换执行为并发。并发在宏观上表现类似于并行。一个CPU同时只能执行一个进程（即并行数小于等于CPU数）。 程序、进程与线程：程序是静态指令集和，进程是正在活动的指令集和，有生命周期和各种状态。线程是进程的执行单元，类比于进程和操作系统的地位。主线程是随着进程被创建一起创建的。进程之间不能共享内存而线程之间可以。 下面分别讨论下线程的生命周期，线程的几种形态，和线程池三个方面。 一、线程的生命周期：1、五个生命周期 1&gt;新建(new)。new出一个线程开始。 2&gt;就绪(runnable)。start()方法执行后开始。java虚拟机会为其创建方法调用栈和程序计数器。不能改成调用run()方法来启动，因为这样系统就会把线程对象当做普通对象，把run()当做一个普通方法而不是线程方法来处理。就绪之后并不是马上执行，而会稍等一小段时间（时间长度由底层平台控制），若想让它立即运行，只需让主线程sleep(1)睡眠1毫秒。 3&gt;运行(running)。就绪的线程随后开始执行run()，然后通过JVM的线程调度器决定（不可控）让它进入运行状态。如果底层平台采用“抢占式调度策略”（桌面和服务器操作系统），即每个线程轮流执行一小会儿（次序由线程优先级决定）。若是“协作式调度策略”（手机等小型设备），必须等该线程通过yield()活sleep()主动放弃所占资源，其中yield()回到就绪状态，sleep()进入阻塞状态。 4&gt;阻塞(blocked)。五种情况会进入阻塞，同样五种方法可以解除阻塞回到就绪（不能直接回到运行），这部分放到后面。 5&gt;死亡(dead)。run()或call()执行结束后自然死亡。或者调用线程的stop()手动死亡。或者抛出exception/error非正常死亡。死亡的线程不可以重新start()。 2、进入阻塞和阻塞解除 运行时的任务进入阻塞的五种情况： 线程调用sleep()方法主动放弃所占资源。 线程调用了一个阻塞式IO方法。 线程试图获得一个同步监视器。 线程在等待某个notify。 程序调用了线程的suspend()将线程挂起。 解除阻塞回到就绪的五种情况： sleep()方法时间到。 阻塞式IO方法已经返回。 成功获得了同步监视器。 其它线程发送了notify。 程序调用了挂起的线程的resume()恢复方法。 二、线程的的几种形态： Thread AsyncTask(底层线程池), IntentService(底层直接用线程),是一种服务不是后台线程，优先度高不易被杀死。 HandlerThread(底层直接用线程)。 三、线程池。 除非线程数小于等于CPU核心数，否则线程不可能做到绝对的并行，只会通过时间片轮转的方式调度每个线程。因此需要一个线程池存放线程的缓存，否则大量线程的创建和销毁会消耗大量时间，入不敷出。 1、ThreadPoolExecutor的六个构造参数 线程池类ThreadPoolExecutor实现了接口Executor（事实上Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService，而ThreadPoolExecutor其实是实现了ExecutorService接口,关系见最下方图片）。其构造器共接受六个参数： int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory. 分别是核心线程数，最大线程数（到达最大线程数后后续任务被阻塞），闲置超时时长（非核心任务闲置超过该参数就会被回收），时长单位（是一个枚举），任务队列（通过线程池的execute方法提交的Runnable对象会存在这里），线程工厂（可创建新线程）。 拿熟悉的AsyncTask来说，它里面有两个线程池，分别是SerialExecutor和THREAD_POOL_EXECUTOR，前者用于任务的排队，后者是真正的执行任务。查看AsyncTask源码可以看到它对THREAD_POOL_EXECUTOR这个线程池进行了配置，这些参数的配置情况如下： private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = CPU_COUNT + 1; private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE = 1; private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); } private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =new LinkedBlockingQueue&lt;Runnable&gt;(128); public static final Executor THREAD_POOL_EXECUTOR= new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); ThreadPoolExecutor线程池执行任务时规则如下：1、线程池中线程数小于核心线程数，则直接启动一个核心线程。2、线程数超过核心线程数，进入任务队列排队。3、任务队列满了，启动一个非核心线程存放下一个任务。4、达到线程池最大线程数了，任务被拒绝。同时RejectedExecutionHandler会调用rejectedExecution()来通知调用者。 另外关于keepAliveTime参数，它是针对非核心线程超时情况，核心线程默认会一直存活。若想使得闲置的核心线程同样在keepAliveTime到时时被回收，只需将ThreadPoolExecutor的allowCoreThreadTimeOut参数设为true即可。 2、四种常见线程池。 它们都是通过Executors类（注意不是Executor接口，Executors类的作用正是创建线程池）的方法newXXXXThreadPool来创建，将线程放入线程池的操作都是通过它们自己的对象调用execute()/submit()方法（两者的区别留到以后讨论..），参数中传入线程名。四种线程池中FixedThreadPool，CachedThreadPool，SingleThreadExecutor是实现的ExecutorService接口（创建对象是创建ExecutorService的对象），ScheduledThreadPool是实现ScheduledExecutorService接口。 1&gt;、FixedThreadPool. 只有核心线程且数量固定，线程空闲时不会被回收，任务队列没有大小限制。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 2&gt;、CachedThreadPool. 核心线程数0，非核心线程数任意大。超时时长60秒即被回收。因为最大线程数无限所以其SynchronousQueue队列不需要放入任务。适合大量的小任务。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 3&gt;、ScheduledThreadPool. 核心线程数量固定，非核心线程任意大。超时时长0意味着闲置立马收回。适合定时任务和周期任务。 public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) { return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); } 4&gt;、SingleThreadExecutor. 只有一个线程且是核心线程。意义在于将多个线程统一到同一个线程中。 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } 下面是四种线程池的调用方法示例： Runnable r=new Runnable() { @Override public void run() { //do something } }; ExecutorService ftp= Executors.newFixedThreadPool(4); ftp.execute(r); ExecutorService ctp= Executors.newCachedThreadPool(); ctp.execute(r); ScheduledExecutorService stp= Executors.newScheduledThreadPool(4); stp.execute(r); ExecutorService sintp= Executors.newSingleThreadExecutor(); sintp.execute(r); 最后是完整的线程池的类体系结构，图中清晰地展示了之前用到的Executor,Executors,ExecutorService,ScheduledExecutorService,ThreadPoolExecutor,ScheduledThreadPoolExecutor之间的关系。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"漫谈android异步","date":"2016-04-02T16:38:51.000Z","path":"2016/04/03/漫谈android异步/","text":"Google在Browser中大量的使用了异步任务作为处理耗时的I/O操作，比如下载文件、读写数据库等等。在android中，耗时任务放在主线程会导致阻塞，而android的UI是单线程的，若使用了多线程操作一个UI很容易导致反向加锁和死锁问题，所以只有主线程能操作UI（同样只能在子线程操作网络访问，否则会抛出NetworkOnMainThreadException异常），子线程若想借助主线程影响UI，就是今天要讨论的异步操作。经过学习积累，总结异步实现的方法有如下几种。 1.Thread-Handler消息传递机制 首先是定义并启动一个子线程。继承Thread类和实现Runnable接口都是可以的，总之是要重写它们的run()方法，在里面运行子线程任务。 Message负责线程之间传递消息。包括what，arg1,arg2（携带整型数据）,obj（携带object对象）四种字段。Handler拥有的setMessage（）和handlerMessage（）方法用来传递和接受消息。 MessageQueue消息队列，存放消息。Looper拥有的loop（）方法会无限循环传递MessageQueue中的一条条消息。Looper是与Handler一一对应的。一个线程中只有一个MessageQueue，也只有一个Looper。 所以流程大致是，需要进行后台任务的Thread子线程中创建Message对象并为其赋予一个专属字段，用Hadler对象调用setMessage（）方法将消息发送到MessageQueue队列中。接着主线程中已经建好的Handler对象所对应的Looper会负责读取消息，回掉dispatchMessage()方法将消息传给Handler，Handler中重写父类的handlerMessage()方法，其参数接受一个Message对象，在方法体中判断Message对象字段匹配后执行UI操作。 缺点：有时可能消息队列阻塞或其他原因无法准确的使用。 2.AsyncTask机制 首先要明确AsyncTask机制的实现原理也是基于消息传递机制的，它封装了Thread和Handler。 AsyncTask是抽象类，第一步当然就是创建子类继承它，继承时需要制定三个泛型参数，分别是Params–需要传入的参数比如HTTP请求的URL，Progress–后台执行时的进度如一个表示百分数的数组，Result–执行完毕后的Boolean类型结果。接着是重写父类的四个方法。 onPreExecute()。执行前的初始化，可执行UI任务，比如show一个ProgressDialog。 doInBackground()。我们的子线任务就是在这里执行，不能执行UI操作。与第三个方法互动—可以用pulishProgress()方法讲任务进度传递出去。与第四个方法互动—返回一个boolean类型值，表示任务成功结束否。 onProgressUpdate()。如果上一个方法传递了任务进度，就用这个方法来显示（该方法是被UI主线程调用）。参数一般是不定长度的Interger数组，即Interger…i (三个点表示不定长度参数，i相当于一个int数组)，利用ProgressDialog的setMessage()将进度数组显示在进度条上。 onPostExecute()。任务结束后的收尾。可以dismiss()那个进度条。参数是第二个方法返回的Boolean值，因为也是被UI现成调用所以可以将boolean结果显示出来。参数也可以是第二个方法返回的String值，获取到将异步操作返回的结果。 四个方法不能手动去调用，在主线程中想启动任务，要在主线程中创建任务对象后，调用execute（）即可。 缺点：并不适合特别耗时的后台任务。 3.runOnUiThread方法 在thread子线程的run()中若想进行UI操作，直接调用Activity的一个方法runOnUiThread（），它同Thread的构造器一样接受一个Runnable参数，于是可以用同样的匿名类方式写，在重写的run()方法中进行UI操作即可。之后没有.start()。 runOnUiThread(new Runnable() { public void run() { //do something;}}); 4.Handler/view的post(Runnabel r)方法 就是post一个runnable对象到消息队列，用来更新UI。用法类似于3，在子线程中创建一个Handler对象（或一个View对象）并调用post()方法，其参数是Runnable对象，匿名类并重写run()方法，在里面UI操作。 handler.post(new Runnable(){ public void run() { //do something;}}); 目前知识储备中暂时只有这四种，等get到新技能再回来补充。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"ssd初体验","date":"2016-03-25T15:52:52.000Z","path":"2016/03/25/ssd初体验/","text":"今天的主角是这款去年的明星产品，镁光(crucial)MX200。观望许久售价终于跌破百分之二十，果断入手。 曾在两兄弟BX100 500G版和MX200 250G版之间小犹豫，考虑到最近两年不仅是大型单机，几乎算是已经告别了一切游戏，仅装软件250G应该够用了，另外BX100比起MX200削减的功能有AES硬件加密和断电保护，但这些都不是最致命的，美光居然舍弃了自家主控搭配了Silicon Motion(慧荣)的主控芯片，那我买美光的意义何在。 横向比完再来纵向比比，和之前的型号MX100相比区别之一是闪存芯片，虽同样是MLC颗粒，MX100的128G版本是20nmMLC，剩下两个版本和MX200所有版本都是16nmMLC。关于制程工艺的发展真可谓日新月异，五年前还是34nm/25nm的天下，后来英特尔和美光推出20nm工艺的MLC NAND,三星推出21nm,东芝推出19nm，人们还在担心随着制程技术的提高擦写次数可能会跌破300PE，如今16nm上阵而擦写次数似乎保持住了。究其原因，制程越先进，一颗cell(晶圆)上能生产出更多芯片，闪存颗粒中用于读写的氧化物层会越薄，每一次完整的P/E，都会对氧化物层造成损耗，加上电子易流失易蒸发，于是能承受的P/E次数也会越少。这也是现在闪存市场上MLC与TLC争夺的焦点所在。TLC能做到3bit/cell，速度慢寿命短，最多没有达到1000PE的，所以一般只存在于U盘中。但如今TLC有在SSD领域赶超MLC之势，原因就在于更低的成本但又能获得更高的容量，这对于一般以容量作为唯一标准的普通老百姓来说是没有理由拒绝的。目前TLC已经接近一半市场份额，主要是三星在推，结合3D NAND技术在做多TLC，其evo系列tlc甚至卖的和mlc一样贵。 SSD由主控、闪存、缓存、固件等四大部分组成，说完内存颗粒，刚才还提到了主控。MX200选用的是marvell 88SS9189主控，使用marvell 主要是Lite-on（浦科特）和Micron（镁光），英特尔用sandforce的主控牺牲性能延长寿命，OCZ(饥饿鲨)的barefoot(大脚)主控燃烧寿命获取性能。三星和东芝都有自己的主控，性能也都还可以。其他的sm(慧荣)和jm(Jmicron智微)什么的主控，就比较低端了。 参数一览： Marvell 88SS9189主控，八颗美光16nm MLC闪存颗粒，2.5英寸、7mm机身，全系列MX200的最高连续读写速度均为：555/500 MB/s，最高随机读写速度均为：100k/87k IOPS。DWA动态写入加速技术，256位AES加密支持，对R.A.I.N的支持。动态写入加速(AWA)，这是美光自己的SLC缓存加速方案。缓存大小是动态的，根据硬盘里的数据量而定，空盘就是纯粹的SLC模式，随着可用空间的减少缓存也越来越小。 下面回顾下安装流程： 取出机械硬盘，自带的是日立HTS541010A9E680，日立从12年起标签上的标志由Hitachi改成了HGST，HGST与WD(西部数据)目前为WDC旗下独立营运的两家子公司，拥有不同的品牌和产品线，这也是美国反垄断法的功劳。这块硬盘是6Gb/s的SATA接口，5400转，8M缓存，1T容量。 拿出我们的MX200，铝制外壳，风格是老式样，深色贴纸银色字条，背面贴着铭牌,上面内容包括有：型号：CT250MX200SSD1，256GB容量，SATA3 6GB /S接口，额定电压5V，0.7A的电流。各种认证：CE,ATA标准，FC，可回收利用环保等等。 有心拆解一探内部构造，但是铝制外壳的无螺丝卡扣非常紧，怕暴力拆解直接报废。只能在网上找拆解评测过过眼瘾了。单面电路布局，主要核心用料都在一面。左面是8个16NM MLC的NAND颗粒共250GB容量，右下角较大的就是前面聊过的Marvell主控，上面是一片DDR3缓存芯片，缓存这东西在机械硬盘上意义重大，固态硬盘中作用就大打折扣了。 两个硬盘的对比 由于光驱位是SATA2接口，装固态会限制其性能。所以选择把机械硬盘安在光驱位硬盘托架放入光驱位。 接下来也很简单，开机后用分区助手6.2将系统盘迁移到固态盘，注意迁移前检查错误，迁移后分区对齐–4K对齐，重启时迁移自动完成。 然后是BIOS设置。华硕本本一律开机时狂点F2，进入后先将SATA Mode Selection开启AHCI，由于这里系统本来就是SATA串口传输模式所以是开着的。然后Boot启动顺序将固态放在首位，这里第二位的是我自装的黑苹果系统。 开机后进行测试。ASSSD得分如下。第一行seq是持续测试，读写速度在500左右。第二行4K测试即随机单队列深度测试，seq是1G大小的文件读写测试，4K只是一个小文件，所以4K测试结果相比之下在平常使用时意义更大。第三行64队列4K测试，传输数据量同seq一样是1G，但是是以4KB为单位在64个16MB的文件中读取测试。最后一行数据存储时间测试。 最后一项Crystaldiskinfo测试，将机械硬盘也放出来作对比，完事收工！","tags":[{"name":"Hardware","slug":"Hardware","permalink":"http://yoursite.com/tags/Hardware/"}]},{"title":"熔炉Silenced","date":"2016-03-21T16:32:22.000Z","path":"2016/03/22/RongLu/","text":"这个镜头最打动我，男主形象瞬间万丈光芒！ 这部片最压抑的地方在于从头到尾笼罩的孤独感。最开始三个聋哑儿童在偌大的学校却孤立无援，偷跑到警察局却发现又入狼窝；直到男主角开始介入，但这种孤独感却从未消散。 孤身在外的男主角没有朋友没有妻子，只有母亲却也不能倾诉所有；引入女主角就是为了带来一丝暖意，五个人夕阳下行走在海滩玩耍是唯一的暖色调镜头，但却徒增了更浓的孤独感。至始至终只有两个人在硬抗着这一切，站过来伸出援助之手的几乎没有。开始帮助引入证据的证人一律在法庭上叛变，受害人的家属不是残疾就是智障，看似公正的法官最终也是同伙，甚至连最后的示威游行，在我们以为终于有雾津市市民不再麻木哪怕不能有结果也能给予男主主角一丝鼓励温暖的时候，发现抗议的也只有区区不多的残障家长。男主哭着举着遗像向周围围观群众（甚至围观人都不多）大喊男孩名字，因为独自承担这一切真的太累了，他想得到其他人的鼓励或是仅仅让别人了解这个故事都是奢侈。就连最后的圣诞节，被女主角信里描述的美好的结局———事实上也只是一间昏暗狭小的屋子里，她和男配角带领一群残疾孩子强颜欢笑。除了孩子受虐，世人的冷漠带来的孤独更为片子涂上一层灰色调。 像极了终日忙碌的自己，也像极了死前脱离群体的大象，或许只是怕合眼之前，看到同伴虚伪到轻如薄纸的关心和同情，还得尽最后一分力气回以虚伪的感激。封装好的类只把接口伸向外界，扭头回到自己的小花园，安之若素，冷暖自知。 评分8.0","tags":[{"name":"movie","slug":"movie","permalink":"http://yoursite.com/tags/movie/"}]},{"title":"布鲁克林Brooklyn","date":"2016-03-20T16:33:47.000Z","path":"2016/03/21/Brooklyn/","text":"今天起除了技术博客外，也把自己的观影体验记录上来，每篇末尾有一个自己满分为十分的打分。 虽然在异国他乡胆怯孤独，虽然时刻思念家乡的亲人，虽然家乡可以有一个稳定的工作和足以让乡里人羡慕的丈夫， 但和所以去大城市拼搏的年轻人一样，女主角在短暂迷茫后还是选择了美国。 “我忘了这个镇是什么样的了”，这不过是一个文明化了的&lt;狗镇&gt;里的小镇和&lt;金福南&gt;中的小岛，遍地充斥着市井气息，伪善（开头弥撒时女主打阿欠）、人情（店老板让贵妇人插队）、势利（母亲暗示女主男方有房）、道德绑架（得知女主离开时店老板以孝顺母亲进行绑架）、以及安于现状和不思进取，像极了我所在家乡，人人托关系往体制内挤谋求旱涝保收的低薪“正式”工作，人情社会决定前途的不是实力而是关系网，捂住双眼不去接纳新世界的繁华固守自己一亩三分地还能渐渐培养出一种畸形的自豪感和满足感，山西已经连年GDP增速垫底，被产业转型和互联网浪潮远远抛在身后，宛如一潭死水。 回到电影，在毅然返回美国的途中，女主也把代表着这一代移民的精神传承了下去，这是值得尊敬和赞美的一代人。一直觉得女主角眼熟，看完查介绍原来是＜布达佩斯大饭店＞里的蛋糕女孩－－同样单纯的美好一个角色。全片细腻悠长，点到为止，真实改编加美国梦的政治正确有点像为奥斯卡提名量身定做，但也仅能止步于提名了。 评分：7.9","tags":[{"name":"movie","slug":"movie","permalink":"http://yoursite.com/tags/movie/"}]},{"title":"小白兔的三向切分快排之旅","date":"2016-03-19T18:06:28.000Z","path":"2016/03/20/3-way-partition/","text":"相比快排的精妙，三向切分快排更加妙不可言，初次见他时甚至忍不住拍手叫好（并没有真在图书馆拍手），短短几行代码轻描淡写却又字字珠玑，下面来感受一下： private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo; while (i &lt;= gt) { int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; } // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. sort(a, lo, lt-1); sort(a, gt+1, hi); } 小兔子i紧紧地牵着弟弟lo去拔萝卜，如果是太小的萝卜就和弟弟交换(原因我实在编不出来了摔！): if (cmp &lt; 0) exch(a, lt++, i++); 太巨大的就扔给对面的妈妈gt栽坑，妈妈把大萝卜栽下去用来挡风沙，然后往前走一步坐下休息: else if (cmp &gt; 0) exch(a, i, gt--);//这里gt--是为了指针前移继续遍历，而i后面没有++，则是因为妈妈换回来的可能也是一颗大萝卜，怎么能不观察判断下这颗就急着走呢。 这么愉快地走着，突然看到一个个头和弟弟一样大，和萌萌哒弟弟一样让人看着就流口水，于是决定拿回去做今天的午餐，就撒开手让弟弟站着守着午餐别动，自己接着找: else i++; 大的继续留给妈妈，遇到屁点大小的就捡起来砸弟弟一下，喊他把午餐扔过来，每次扔时弟弟都用尽全力往前走一步助跑。这样小兔子一路把大的小的都清理掉，回头一看一大堆可口的午餐和远处一脸无辜的弟弟。直到和妈妈碰头，收工扛萝卜回家！ 这就是三向切分的思路，只要再把那堆小萝卜和大萝卜同样的方式无限切分下去，就完成了对大量重复元素数组的高效排序。但是细琢磨，追求极简主义的三向快排也有个问题： 在第一次碰到与cmp相同的元素之前，遍历小元素期间，lt与i完全没必要进行交换这一多余操作，直接同时++即可，交换操作的意义仅仅存在于有了与cmp相同的元素之后的时间段，即将等值数列以尾变头的形式整体右移。旁边小白兔搭话了，可不是！开始时让我和弟弟捡起各自脚底的小萝卜头互相交换再放下，这么反常诡异的举动宝宝不情愿啊！如果考虑下面的数组 8 2 3 4 1 2 1 5 2 4 1 2 3 6 1 3 2 ... 碰到这种蛋疼的数组会出现一定数量的无意义交换操作，但Boss级大神Dijkstra老爷爷不可能没想到这个，追加判断i第一次遇到一样大的元素的条件句势必会影响代码的简介，增加空间占用量，得不偿失。最重要的是破坏整体美感！试想五言绝句两句之间穿插一个条件状语从句会是什么体验！","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"Shell与Merge性能大比拼","date":"2016-03-18T20:33:57.000Z","path":"2016/03/19/shellmerge/","text":"比起Quick快排的风光无限，Shell和Merge不免稍显暗淡，但Shell的变幻莫测和Merge在大样本中的厚积薄发令他俩同样令人着迷，况且Quick也正是在Merge的divide-and-conquer思想下诞生的。与C++不同，java在对操作的依赖性上compare大于exchange，这又决定了jdk8中一定样本范围内选用快排而超出之后则选用Merge（Merge比较次数可以比快排更少）。另外谈及快排绕不过的一点是，快排的优越是建立在Amortized Cost下，尽管概率极小但仍有可能到达N^2，就像一根哽在喉间鱼刺。同样强不稳定性的还有ShellSort,最坏情况是N^3/2(N^4/3\\、N^5/4、N^6/5..似乎没有定论)，但其小巧的代码量和并不逊色的速度也让很多人对它情有独钟。《Algorithms》中对两者是这样评价的： In practice, their running times are within a small constant factor of one another , so comparative performance depends on the implementations. % java SortCompare Merge Shell 100000 For 100000 random Double values Merge is 1.2 times faster than Shell In theory, no one has been able to prove that shellsort is linearithmic for random data, so there remains the possibility that the asymptotic growth of the average-case performance of shellsort is higher. Such a gap has been proven for worst-case performance, but it is not relevant in practice. 本着实践出真知的精神，我用如下代码对它俩进行了一番测试。 测定某一方一次运行的耗时： public static double time(String alg, Double[] a) { long tim1=System.currentTimeMillis(); if (alg.equals(&quot;Shell&quot;)) Shell.sort(a); else if (alg.equals(&quot;Merge&quot;)) Merge.sort(a); else throw new IllegalArgumentException(&quot;Invalid algorithm: &quot; + alg); long tim2=System.currentTimeMillis(); return tim2-tim1 ; } 对给定的T个含有N个元素的数组，随机分配每个元素，调用T次time方法测出总时间： public static double timeRandomInput(String alg, int N, int T) { double total = 0.0; Double[] a = new Double[N]; for (int t = 0; t &lt; T; t++) { for (int i = 0; i &lt; N; i++) a[i] = random.nextDouble(); total += time(alg, a); } return total; } 改变N和T的值开始测试： public static void main(String[] args) { int N = 1000 int T = 100; double time1, time2; time1 = timeRandomInput(&quot;Shell&quot;, N, T); time2 = timeRandomInput(&quot;Merge&quot;, N, T);  Double timesum=time1+time2; System.out.printf(&quot;%d个元素的数组中，\\n %s的速度是&quot;, N, &quot;Shell&quot;); System.out.printf(&quot;%s的 %.1f 倍哦 \\n&quot;, &quot;Merge&quot;,time2/time1); System.out.printf(&quot; 整个对比过程耗时&quot;+timesum+&quot;毫秒&quot;); } 第一次： 第二次： 第三次： 第四次： 是的，百万个数组元素时已经等到了１９９秒－－４分钟。 看出我们跟书本上得出了相反的结果，这自然跟很多因素有关，但同样也证实了两点： 1、Shell和Merge的order of growth都在NlogN级别，相差也不过是常数级别，以至于孰优孰劣会在外界条件改变下互相转换。 2、Shell的asymptotic growth（渐进增长率）更高，随着N值的十倍增长，Shell的领先优势被拉小，在可预见的阈值下会被反超。 其实不只他俩，一切compare-based排序都受制于NlgN这个级别，正如Sedgewick在《Algorithms》中所言： both the number of compares used by mergesort in the worst case and the minimum number of compares that any compare-based sorting algorithm can guarantee are ~NlgN.","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]},{"title":"搭建hexo小屋的踩坑历程","date":"2016-03-14T05:52:42.000Z","path":"2016/03/14/my-new-post/","text":"耗费一整天时间终于搭好了这个小blog，总的来说花样坑集中在以下几个方面： 1.配置_config.yml文件时repository选择https还是SSH的问题。 2.一次更改github上repository仓库目录之后公匙验证失败问题。 3.创建好SSH公匙并传到github SSH key上后本地私匙无法添加到SSH代理中。 4.其他一些细节问题。 首先，拷贝github库地址时开始一直使用https地址，deploy时报如下错误：… Error: bash: /dev/tty: No such device or address error: failed to execute prompt script (exit code 1) fatal: could not read Username for &apos;https://github.com&apos;: No error SegmentFault上的普遍解决方案是换SSH，于是满心欢喜改成SSH，万没想到即将面临的是一个更大的天坑。 然后就是漫长的与SSH缠斗的时间。因为之前半途更改了一次github的repository路径，hexo d时抛错： error: Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 看来即使更改配置文件中的repository地址仍然会导致公匙验证失败。摸索后的解决方法是删掉hexo文件，重新安装加初始化，该问题解决。 接下来最终BOSS error登场，一半时间就耗在它身上： Error: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 参考github官方文档，可能是向github提交公匙环节出了问题。一步步回溯，先检查SSHKey：ls -al ~/.ssh，确认其存在。查看该KEY能否使用，先建一个代理eval &quot;$(ssh-agent -s)&quot;，查看本地的私匙ssh-add -l -E md5，正常情况会返回一长串密匙，但是显示如下错误： The agent has no identities. 这是按照官方步骤一步步执行，根据官方帮助文档建议此时要重新返回去创立新key，但重头再来几次都仍然卡在这一步，最后在stackoverflow上找到解决办法。代理打开之后要通过ssh-add ~/.ssh/id_rsa向该进程内添加自己的私钥文件后才能显示，试后成功。接着hexo d，代码成功传入github，泪流满面。但故事远没有就此结束。由于repository名和github账号名不同导致页面404错误，更改repository后老问题Permission denied (publickey).再次出现，并且用上述方法无法解决。经过无数次尝试，在代理开辟前执行`$ ssh-agent bash，问题再次解决。 另外还碰上的一些零星小坑包括： 1&gt; ERROR Deployer not found: git 解决方法：再来一次npm install hexo-deployer-git --save 2&gt; Error: fatal: Not a git repository (or any of the parent directories): .git 解决方法：重新init一遍 3&gt;hexo -version查看自己的hexo版本，如果是3.0以后配置_config.yml要把type改为git，否则又是查不出缘由的错误。 4&gt;ssh -T -v git@github.com非常好用的debug命令，通过它我找出如下错误： debug1: Trying private key: /home/sunny/.ssh/id_rsa debug1: Trying private key: /home/sunny/.ssh/id_dsa debug1: Trying private key: /home/sunny/.ssh/id_ecdsa debug1: No more authentication methods to try. 说明id_rsa等密匙文件找不到而导致的出错，可以通过cp github id_rsa &amp;&amp; cp gitbub.pub id_rsa.pub还原出改之前所需文件。 5&gt;最后编辑完.md文件保存时别忘选UTF-8编码避免中文乱码。 整个过程虽然痛苦，但是不借助别人帮助下自己发现并解决问题，也算是对毅力和信心的一次小小提升^ ^。","tags":[{"name":"Code","slug":"Code","permalink":"http://yoursite.com/tags/Code/"}]}]