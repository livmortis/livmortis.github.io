无向图中遍历所有点的方法
深度优先（判断两点是否连通）：一副无向图和一个起点，遍历起点的邻接点，每次遍历都进行递归。
          遍历全图的顺序和找出最短路径没关系。
广度优先（找出两点最短路径）：一副有向图和一个起点，遍历起点的邻接点，每个点放入队列。遍历完一次，队列删一个点（上次遍历那个点），接着遍历。直到队列空。
连通分量：连通分量中任意点等价。
找出连通分量数：每次深度优先count加一。



有向图。
逆后序排列：深度优先搜索全部顶点，每次递归之后将点放入一个栈中（放入队列是后序排列，递归前放入队列是前序排列）。
拓扑排序（优先级限制下的调度问题）：目标是使所有有向边都是从前元素指向后元素。方式即为所有顶点的逆后序排列。
强连通分量：强连通分量里面的任意点互相都可达。
找出强连通分量数（Kosaraju算法）：先深度优先该图的反向图，并得出反向图的拓扑排序。根据这个顺序再次深度优先该图原图，递归一次count加一即有一个强连通分量。






加权无向图（目的是求最小生成树）
贪心算法：不断找出横切边中的最小者，根据切分定理，最终这些最小横切边形成的就是最小生成树。
Prim算法：遍历每个顶点的邻接边，从而得到邻接点，若该"邻接边"比"该邻接点和树之间的最小边"还小，更新这个最小边的值为该邻接边，该点加入树中。接着从树中找最近的顶点，继续遍历...
Kruskal算法：所有边按权重从低到高排，依次加入树中。


加权有向图（目的求最短路径）
Dijkstra算法：遍历每个顶点的邻接边，若顶点的"起点距离"加邻接边的和，比"该邻接点到起点的最短路径"还小，放松这段最短路程，该点加入树中，接着从树中找最近的顶点。
Bellman-Frod算法：需要检测负权重环，且选择下一个顶点是根据FIFO队列每次删除后的下一个点来选。










二叉查找树（BST）： 每个节点有一个键，一个值，一条左链接，一条右链接，一个节点计数器。
                    每个节点的键大于左子树，小于右子树。
          二叉树的删除：用后继结点（它右子树中的最小结点）代替被删结点。



二三查找树：所有空连接到根节点的距离相同。（平衡）
红黑树：红链接连接两个2结点构成一个3结点，黑链接是23查找树中的普通链接。
        红链接在左；没有结点连接两条红链接；完美黑色平衡。